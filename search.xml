<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css-那些你常用又记不住的css</title>
      <link href="2021/03/18/%E5%89%8D%E7%AB%AF/css/css-%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%8F%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84css/"/>
      <url>2021/03/18/%E5%89%8D%E7%AB%AF/css/css-%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%8F%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84css/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录一些常用Css效果</p><span id="more"></span><h2 id="一、设置input-的placeholder的字体样式"><a href="#一、设置input-的placeholder的字体样式" class="headerlink" title="一、设置input 的placeholder的字体样式"></a>一、设置input 的placeholder的字体样式</h2><pre><code class="less">input::-webkit-input-placeholder &#123;    /* Chrome/Opera/Safari */    color: red;&#125;input::-moz-placeholder &#123; /* Firefox 19+ */      color: red;&#125;input:-ms-input-placeholder &#123; /* IE 10+ */    color: red;&#125;input:-moz-placeholder &#123; /* Firefox 18- */    color: red;&#125;</code></pre><h4 id="设置input聚焦时的样式"><a href="#设置input聚焦时的样式" class="headerlink" title="设置input聚焦时的样式"></a>设置input聚焦时的样式</h4><pre><code class="css">input:focus &#123;       background-color: red;&#125;</code></pre><h4 id="取消input的边框"><a href="#取消input的边框" class="headerlink" title="取消input的边框"></a>取消input的边框</h4><pre><code class="css">input &#123;    border: none;    outline: none;&#125;</code></pre><h2 id="二、隐藏滚动条或更改滚动条样式"><a href="#二、隐藏滚动条或更改滚动条样式" class="headerlink" title="二、隐藏滚动条或更改滚动条样式"></a>二、隐藏滚动条或更改滚动条样式</h2><pre><code class="css">/*css主要部分的样式*//*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/::-webkit-scrollbar &#123;    width: 10px; /*对垂直流动条有效*/    height: 10px; /*对水平流动条有效*/&#125;/*定义滚动条的轨道颜色、内阴影及圆角*/::-webkit-scrollbar-track&#123;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: rosybrown;    border-radius: 3px;&#125;/*定义滑块颜色、内阴影及圆角*/::-webkit-scrollbar-thumb&#123;     border-radius: 7px;    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);    background-color: #E8E8E8;&#125;/*定义两端按钮的样式*/::-webkit-scrollbar-button &#123;    background-color:cyan;&#125;/*定义右下角汇合处的样式*/::-webkit-scrollbar-corner &#123;    background:khaki;&#125;</code></pre><h2 id="三、文字超出隐藏并显示省略号"><a href="#三、文字超出隐藏并显示省略号" class="headerlink" title="三、文字超出隐藏并显示省略号"></a>三、文字超出隐藏并显示省略号</h2><h4 id="单行（一定要有宽度）"><a href="#单行（一定要有宽度）" class="headerlink" title="单行（一定要有宽度）"></a>单行（一定要有宽度）</h4><pre><code class="css">p &#123;    width:200rpx;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;&#125;</code></pre><h4 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h4><pre><code class="css">p &#123;    word-break: break-all;    display: -webkit-box;    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    overflow: hidden;&#125;</code></pre><h2 id="四、控制div内的元素自动换行"><a href="#四、控制div内的元素自动换行" class="headerlink" title="四、控制div内的元素自动换行"></a>四、控制div内的元素自动换行</h2><pre><code class="css">div &#123;    word-wrap: break-word;    word-break：break-all;&#125;</code></pre><h2 id="五、-纯css画三角形"><a href="#五、-纯css画三角形" class="headerlink" title="五、 纯css画三角形"></a>五、 纯css画三角形</h2><pre><code class="css">#demo &#123;    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;&#125;</code></pre><h2 id="六、-绝对定位元素居中（水平和垂直方向）"><a href="#六、-绝对定位元素居中（水平和垂直方向）" class="headerlink" title="六、 绝对定位元素居中（水平和垂直方向）"></a>六、 绝对定位元素居中（水平和垂直方向）</h2><pre><code class="css">#demo &#123;    width: 200px;    height: 200px;    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);    background-color: green;&#125;</code></pre><h2 id="七、表格边框合并"><a href="#七、表格边框合并" class="headerlink" title="七、表格边框合并"></a>七、表格边框合并</h2><pre><code class="css">table,tr,td&#123;    border: 1px solid #333;&#125;table&#123;  border-collapse: collapse;&#125;</code></pre><hr><p>参考文档:<a href="https://zhuanlan.zhihu.com/p/228168219">知乎专栏:那些你常用又记不住的css:</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器端-docker安装Nginx</title>
      <link href="2021/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/docker/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-docker%E5%AE%89%E8%A3%85Nginx/"/>
      <url>2021/03/18/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/docker/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-docker%E5%AE%89%E8%A3%85Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用docker安装nginx,映射目录并配置通过https访问</p><span id="more"></span><h2 id="一-安装docker"><a href="#一-安装docker" class="headerlink" title="一 安装docker"></a>一 安装docker</h2><p>首先了解<a href="https://www.docker.com/">docker</a>,在<strong>centos</strong>下快速通过以下命令安装docker:</p><pre><code>curl -sSL https://get.daocloud.io/docker | sh</code></pre><p>其它系统或其它安装方式可以在<a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a>中了解</p><h2 id="二-下载nginx镜像"><a href="#二-下载nginx镜像" class="headerlink" title="二 下载nginx镜像"></a>二 下载nginx镜像</h2><pre><code class="ruby">docker pull nginx:latest</code></pre><p>可以通过以下命令查看是否已经安装nginx</p><pre><code>docker images</code></pre><h2 id="三-启动容器并做好映射"><a href="#三-启动容器并做好映射" class="headerlink" title="三 启动容器并做好映射"></a>三 启动容器并做好映射</h2><h3 id="1-执行以下命令"><a href="#1-执行以下命令" class="headerlink" title="1 执行以下命令"></a>1 执行以下命令</h3><pre><code>docker run --name nginx -d -p 80:80 -p 443:443 \-v /data/nginx/html:/usr/share/nginx/html \-v /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /data/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \-v /data/nginx/logs:/var/log/nginx \-v /data/nginx/cert:/etc/nginx/cert \nginx</code></pre><h3 id="2-涉及到的指令和文件夹如下"><a href="#2-涉及到的指令和文件夹如下" class="headerlink" title="2 涉及到的指令和文件夹如下:"></a>2 涉及到的指令和文件夹如下:</h3><p><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</p><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></p><p>​    映射端口443，用于https请求;</p><p>​    映射端口80，用于http请求；</p><p><strong>-v:</strong>  本地目录:容器目录。例:挂载主机的本地目录 <code>/data/nginx/html</code> 目录到容器的<code>/usr/share/nginx/html</code> 目录，本地目录的路径必须是绝对路径;</p><p>​    <strong>注意</strong>:本地目录可以通过<code>mkdir -p [绝对路径]</code>生成,可以自定义位置,以下展示位置仅供参考,容器目录需要以自身的实际目录位置为准,你需要进入到容器确认文件夹位置;(ps:不会进入到容器看文件夹?点击了解<a href="https://www.runoob.com/docker/docker-container-usage.html">容器使用方法</a>)</p><p>​    <code>/data/nginx/html</code>   用于存放静态资源</p><p>​    <code>/data/nginx/conf/nginx.conf</code>   nginx配置项</p><p>​    <code>/data/nginx/conf.d/default.conf</code>  nginx默认配置项</p><p>​    <code>/data/nginx/logs</code> 存放nginx产生的log日志</p><p>​    <code>/data/nginx/cert</code> 存放证书文件和私钥</p><p>更多详细指令可以在<a href="https://www.runoob.com/docker/docker-run-command.html">菜鸟教程Docker run 命令</a>查看到</p><p>通过<code>docker ps</code>查看是否启动成功,列表中存在nginx并且存在的容器ID与运行时返回的容器ID一致,则为成功</p><h2 id="3-配置访问https"><a href="#3-配置访问https" class="headerlink" title="3 配置访问https"></a>3 配置访问https</h2><p>在<code>/data/nginx/conf/nginx.conf</code>中的<code>http &#123; server &#123;&#125;&#125;</code>中追加ssl配置内容,内容如下</p><pre><code> # 增加ssl    #ssl on;        #如果强制HTTPs访问，这行要打开    ssl_certificate /etc/nginx/cert/com_bundle.crt; #证书位置    ssl_certificate_key /etc/nginx/cert/com.key; #秘钥位置    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;     # 指定密码为openssl支持的格式     ssl_protocols  SSLv2 SSLv3 TLSv1.2;     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码</code></pre><p>参考完整的<code>nginx.conf</code>配置如下:</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;   server &#123;     listen 80 ;# 监听本机所有 ip 上的 80 端口     listen 443 ssl;     server_name www.tangyuxian.com;# 域名：www.example.com 这里 &quot;_&quot; 代表获取匹配所有     root /usr/share/nginx/html/blog;# 站点根目录     index index.html /;    # 增加ssl    #ssl on;        #如果强制HTTPs访问，这行要打开    ssl_certificate /etc/nginx/cert/1_tangyuxian.com_bundle.crt;    ssl_certificate_key /etc/nginx/cert/2_tangyuxian.com.key;    ssl_session_cache    shared:SSL:1m;    ssl_session_timeout  5m;     # 指定密码为openssl支持的格式     ssl_protocols  SSLv2 SSLv3 TLSv1.2;     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码   &#125;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;</code></pre><h2 id="4-对当前容器启动方面操作"><a href="#4-对当前容器启动方面操作" class="headerlink" title="4 对当前容器启动方面操作"></a>4 对当前容器启动方面操作</h2><p>启动已被停止的容器nginx</p><pre><code>docker start nginx</code></pre><p>停止运行中的容器nginx</p><pre><code>docker stop nginx</code></pre><p>重启容器nginx</p><pre><code>docker restart nginx</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发工具-git设置代理模式</title>
      <link href="2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为git设置代理,分为全局代理和局部代理</p><span id="more"></span><h2 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h2><h3 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h3><p>git config –global http.proxy <code>[IP地址]</code>:<code>[端口号]</code></p><p><strong>例:</strong> git config –global http.proxy 127.0.0.1:1087</p><h3 id="局部代理，在github-clone-仓库内执行"><a href="#局部代理，在github-clone-仓库内执行" class="headerlink" title="局部代理，在github clone 仓库内执行"></a>局部代理，在github clone 仓库内执行</h3><p>git config –local http.proxy <code>[IP地址]</code>:<code>[端口号]</code></p><p><strong>例:</strong> git config –local http.proxy 127.0.0.1:1087</p><h2 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h2><h3 id="查询全局代理"><a href="#查询全局代理" class="headerlink" title="查询全局代理"></a>查询全局代理</h3><p>git config –global http.proxy</p><h3 id="查询局部代理"><a href="#查询局部代理" class="headerlink" title="查询局部代理"></a>查询局部代理</h3><p>git config –local http.proxy</p><h2 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h2><p>git config –global –unset http.proxy<br>git config –local –unset http.proxy</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/8c5bb8eee8b2">简述:git设置代理模式，仅为github设置代理</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-Vuex从使用到原理解析</title>
      <link href="2021/03/16/%E5%89%8D%E7%AB%AF/vue/vue-Vuex%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>2021/03/16/%E5%89%8D%E7%AB%AF/vue/vue-Vuex%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p><span id="more"></span><h2 id="一、Vuex是什么"><a href="#一、Vuex是什么" class="headerlink" title="一、Vuex是什么"></a><strong>一、Vuex是什么</strong></h2><p>Vuex是专门为Vuejs应用程序设计的<strong>状态管理工具</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h3 id="1、Vuex的构成"><a href="#1、Vuex的构成" class="headerlink" title="1、Vuex的构成"></a><strong>1、Vuex的构成</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-f330e46f1a97cfe60b8914802688083b_720w.jpg" alt="img"></p><p>由上图，我们可以看出Vuex有以下几个部分构成：</p><p><strong>1）state</strong></p><p>state是存储的单一状态，是存储的基本数据。</p><p><strong>2）Getters</strong></p><p>getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。</p><p><strong>3）Mutations</strong></p><p>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）</p><p><strong>4）Actions</strong></p><p>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）</p><p><strong>5）Module</strong></p><p>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</p><pre><code class="javascript">const moduleA = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态</code></pre><p><strong>6）辅助函数</strong></p><p>Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。</p><h3 id="2、Vuex的使用"><a href="#2、Vuex的使用" class="headerlink" title="2、Vuex的使用"></a><strong>2、Vuex的使用</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-90437dee8c4d7b465b2d0e6e07778ff0_720w.png" alt="img"></p><pre><code class="javascript">import Vuex from &#39;vuex&#39;;Vue.use(Vuex); // 1. vue的插件机制，安装vuexlet store = new Vuex.Store(&#123; // 2.实例化store，调用install方法    state,    getters,    modules,    mutations,    actions,    plugins&#125;);new Vue(&#123; // 3.注入store, 挂载vue实例    store,    render: h=&gt;h(app)&#125;).$mount(&#39;#app&#39;);</code></pre><h2 id="二、Vuex的设计思想"><a href="#二、Vuex的设计思想" class="headerlink" title="二、Vuex的设计思想"></a><strong>二、Vuex的设计思想</strong></h2><p>Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。</p><p>看了Vuex设计思想，心里难免会有这样的疑问：</p><ul><li>vuex的store是如何挂载注入到组件中呢？</li><li>vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？</li></ul><h2 id="三、Vuex的原理解析"><a href="#三、Vuex的原理解析" class="headerlink" title="三、Vuex的原理解析"></a><strong>三、Vuex的原理解析</strong></h2><p>我们来看下vuex的源码，分析看看上面2个疑惑的问题：</p><p><strong>疑问1：vuex的store是如何挂载注入到组件中呢？</strong></p><p>1、在vue项目中先安装vuex，核心代码如下：</p><pre><code class="javascript">import Vuex from &#39;vuex&#39;;Vue.use(vuex);// vue的插件机制</code></pre><p>2、利用vue的<a href="https://link.zhihu.com/?target=https://cn.vuejs.org/v2/guide/plugins.html">插件机制</a>，使用Vue.use(vuex)时，会调用vuex的install方法，装载vuex，install方法的代码如下：</p><pre><code class="javascript">export function install (_Vue) &#123;  if (Vue &amp;&amp; _Vue === Vue) &#123;    if (process.env.NODE_ENV !== &#39;production&#39;) &#123;      console.error(        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;      )    &#125;    return  &#125;  Vue = _Vue  applyMixin(Vue)&#125;</code></pre><p>3、applyMixin方法使用vue<a href="https://link.zhihu.com/?target=https://cn.vuejs.org/v2/guide/mixins.html">混入机制</a>，vue的生命周期beforeCreate钩子函数前混入vuexInit方法，核心代码如下：</p><pre><code class="javascript">Vue.mixin(&#123; beforeCreate: vuexInit &#125;);function vuexInit () &#123;    const options = this.$options    // store injection    if (options.store) &#123;      this.$store = typeof options.store === &#39;function&#39;        ? options.store()        : options.store    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;      this.$store = options.parent.$store    &#125;&#125;</code></pre><p>分析源码，我们知道了vuex是利用vue的mixin混入机制，在beforeCreate钩子前混入vuexInit方法，vuexInit方法实现了store注入vue组件实例，并注册了vuex store的引用属性$store。store注入过程如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-a8b969f8771a1fc13b7cedfdfe86f0e7_720w.jpg" alt="img"></p><p><strong>疑问2：vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？</strong></p><p>store实现的源码在src/store.js</p><p>1、我们在源码中找到resetStoreVM核心方法：</p><pre><code class="javascript">function resetStoreVM (store, state, hot) &#123;  const oldVm = store._vm  // 设置 getters 属性  store.getters = &#123;&#125;  const wrappedGetters = store._wrappedGetters  const computed = &#123;&#125;  // 遍历 wrappedGetters 属性  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;    // 给 computed 对象添加属性    computed[key] = partial(fn, store)    // 重写 get 方法    // store.getters.xx 其实是访问了store._vm[xx]，其中添加 computed 属性    Object.defineProperty(store.getters, key, &#123;      get: () =&gt; store._vm[key],      enumerable: true // for local getters    &#125;)  &#125;)  const silent = Vue.config.silent  Vue.config.silent = true  // 创建Vue实例来保存state，同时让state变成响应式  // store._vm._data.$$state = store.state  store._vm = new Vue(&#123;    data: &#123;      $$state: state    &#125;,    computed  &#125;)  Vue.config.silent = silent  // 只能通过commit方式更改状态  if (store.strict) &#123;    enableStrictMode(store)  &#125;&#125;</code></pre><p>从上面源码，我们可以看出Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。</p><p>computed计算属性监听data数据变更主要经历以下几个过程：</p><p><img src="https://pic3.zhimg.com/80/v2-2730644102b66eef140110b814a90496_720w.jpg" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>Vuex是通过全局注入store对象，来实现组件间的状态共享。在大型复杂的项目中（多级组件嵌套），需要实现一个组件更改某个数据，多个组件自动获取更改后的数据进行业务逻辑处理，这时候使用vuex比较合适。假如只是多个组件间传递数据，使用vuex未免有点大材小用，其实只用使用组件间常用的通信方法即可。</p><p>Vue组件简单常用的通信方式有以下几种：</p><p>1、父子通信：</p><p>父向子传值，通过props；子向父传值通过events ($emit)；父调用子方法通过ref；provide / inject。</p><p>2、兄弟通信：bus</p><p>3、跨级嵌套通信：bus；provide / inject等。</p><hr><p>文章来源:<a href="https://zhuanlan.zhihu.com/p/78981485">知乎平台慕课网文章:Vuex从使用到原理解析</a></p><p>扩展阅读:<a href="https://www.zhihu.com/question/400812435">为什么vuex不直接挂载到vue原型链上而是使用mixin?</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-Promise相关</title>
      <link href="2021/03/11/%E5%89%8D%E7%AB%AF/es6/es6-Promise%E7%9B%B8%E5%85%B3/"/>
      <url>2021/03/11/%E5%89%8D%E7%AB%AF/es6/es6-Promise%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p><span id="more"></span><h2 id="一、Promise-基本特性"><a href="#一、Promise-基本特性" class="headerlink" title="一、Promise 基本特性"></a>一、Promise 基本特性</h2><ol><li><p> Promise 有三种状态：<strong>pending</strong> (进行中)，fulfilled(<strong>resolve</strong>) (已成功)，<strong>rejected</strong> (已失败)</p></li><li><p> Promise 对象接受一个回调函数作为参数，该回调函数接受两个参数，分别是成功时的回调 resolve 和 失败时的回调 reject；另外 resolve 的参数除了正常值以外，还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例</p></li><li><p> then 方法返回一个新的 Promise 实例，并接受两个参数 onResolved ( fulfilled 状态的回调)，onRejected ( rejected 状态的回调，该参数可选)</p></li><li><p> catch 方法返回一个新的 Promise 实例</p></li><li><p> finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数</p></li><li><p> <strong>Promise.all()</strong> 方法将多个 Promise 实例包装成一个新的 Promise 实例，该方法接受一个由 Promise 对象组成的数组作为参数 （Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例），注意参数中只要有一个实例触发 catch 方法，都会触发 Promise.all() 方法返回的新实例的 catch 方法，如果参数中的某个实例本身调用了 catch 方法，将不会触发 Promise.all() 方法返回的新实例的 catch 方法</p></li><li><p> Promise.race() 方法的参数与 Promise.all() 方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给 Promise.race() 方法，并将返回值作为 Promise.race() 方法产生的 Promise 实例的返回值</p></li><li><p> Promise.resolve() 将现有对象转为 Promise 对象，如果该方法的参数为一个 Promise 对象，Promise.resolve() 将不做任何处理；如果参数是 thenable 对象（即具有 then 方法），Promise.resolve() 方法将该对象转为 Promise 对象并立即执行 then 方法；如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve() 返回一个新的 Promise 对象，状态为 fulfilled，其参数将作为 then 方法中 onResolved 回调函数的参数。如果 Promise.resolve() 方法不传入参数，会直接返回一个 fulfilled 状态的 Promise 对象。需要注意的是，立即 resolve() 的 Promise 对象，是在本轮“事件循环（event loop）”结束时执行，而不是在下一轮“事件循环”的开始时执行</p></li><li><p> Promise.reject() 同样返回一个新的 Promise 对象，状态为 rejected，无论传入任何参数都将作为 reject() 的参数</p></li></ol><h2 id="二、Promise-的优点"><a href="#二、Promise-的优点" class="headerlink" title="二、Promise 的优点"></a>二、Promise 的优点</h2><ol><li><p>统一的异步 API</p><p>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和写法。</p></li><li><p>Promise 与事件对比</p><p>和事件相比较，Promise 更适合处理一次性的结果，在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</p></li><li><p>Promise 和回调对比</p><p>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</p></li><li><p>Promise 带来的额外的好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步工具，比如 Array.prototype.map()）。</p></li></ol><h2 id="三、Promise-的缺点"><a href="#三、Promise-的缺点" class="headerlink" title="三、Promise 的缺点"></a>三、Promise 的缺点</h2><ol><li><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p></li><li><p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p></li><li><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li><li><p>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经执行完了，所以 Promise 的报错堆栈上下文不太友好</p></li></ol><h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现."></a>四、简单代码实现.</h2><p>最简单的 Promise 实现有 7 个主要属性，state(状态），value(成功返回值），reason(错误信息)，resolve 方法，reject 方法，then 方法。</p><h3 id="class版"><a href="#class版" class="headerlink" title="class版"></a>class版</h3><pre><code class="javascript">class Promise&#123;    constructor(executor)&#123;        this.state = &#39;pending&#39;;        this.value = undefined;        this.reason = undefined;        let resolve = value=&gt;&#123;            if(this.state === &#39;pending&#39;)&#123;                this.state = &#39;fulfilled&#39;;                this.value = value;            &#125;        &#125;;        let reject = value=&gt;&#123;            if(this.state === &#39;pending&#39;)&#123;                this.state = &#39;rejected&#39;;                this.reason = value;            &#125;        &#125;;        try&#123;            //立即执行函数            executor(resolve,reject);        &#125;catch(err)&#123;            reject(err);        &#125;    &#125;    then(onFulfilled,onRejected)&#123;        if(this.state === &#39;fulfilled&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);        &#125;;        if(this.state === &#39;rejected&#39;)&#123;            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.reason);        &#125;;    &#125;    &#125;</code></pre><h3 id="function版"><a href="#function版" class="headerlink" title="function版"></a>function版</h3><pre><code class="javascript">function myPromise(constructor)&#123; let self=this;  self.status=&quot;pending&quot; //定义状态改变前的初始状态   self.value=undefined;//定义状态为resolved的时候的状态   self.reason=undefined;//定义状态为rejected的时候的状态   function resolve(value)&#123;    //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的     if(self.status===&quot;pending&quot;)&#123;      self.value=value;      self.status=&quot;resolved&quot;;     &#125;  &#125;  function reject(reason)&#123;     //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的     if(self.status===&quot;pending&quot;)&#123;        self.reason=reason;        self.status=&quot;rejected&quot;;       &#125;  &#125;  //捕获构造异常   try&#123;      constructor(resolve,reject);  &#125;catch(e)&#123;    reject(e);    &#125; &#125;myPromise.prototype.then=function(onFullfilled,onRejected)&#123;   let self=this;  switch(self.status)&#123;    case &quot;resolved&quot;: onFullfilled(self.value); break;    case &quot;rejected&quot;: onRejected(self.reason); break;    default:   &#125;&#125;// 测试var p=new myPromise(function(resolve,reject)&#123;resolve(1)&#125;); p.then(function(x)&#123;console.log(x)&#125;)//输出1</code></pre><p>测试：</p><pre><code class="JavaScript">m = new Promise(resolve=&gt;&#123;    console.log(&#39;aaa&#39;)    setTimeout(function()&#123;        resolve(9000)    &#125;, 2000)&#125;)m.then(res=&gt;console.log(res));//执行</code></pre><p>运行起来我们发现只打印了构造函数中的 aaa 而 异步 then  方法并没有执行。</p><p><img src="https://img-blog.csdnimg.cn/20201216161028331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01GV1NDUQ==,size_16,color_FFFFFF,t_70"></p><p>当then里面函数运行时，resolve由于是异步执行的，还没有来得及修改state，此时还是PENDING状态；因此我们需要对异步的情况做一下处理。</p><h3 id="class进阶版"><a href="#class进阶版" class="headerlink" title="class进阶版"></a>class进阶版</h3><pre><code class="JavaScript">class Promise&#123;    constructor(executor)&#123;        this.state = &#39;pending&#39;;        this.value = undefined;        this.reason = undefined;        this.onFulfilled = [];        this.onRejected = [];         try&#123;            executor(this.resolve,this.reject);        &#125;catch(e)&#123;            this.reject(e);        &#125;            &#125;    resolve = (res)=&gt;&#123;        if(this.state === &#39;pending&#39;)&#123;            this.state = &#39;fulfilled&#39;;            this.value = res;            this.onFulfilled.forEach(fn=&gt;fn(res));        &#125;    &#125;     reject = (res)=&gt;&#123;        if(this.state === &#39;pending&#39;)&#123;            this.state = &#39;rejected&#39;;            this.reason = res;            this.onRejected.forEach(fn=&gt;fn(res));        &#125;    &#125;     then = (onFulfilled,onRejected)=&gt;&#123;        if(this.state === &#39;fulfilled&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);        &#125;        if(this.state === &#39;rejected&#39;)&#123;            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.value);        &#125;        if(this.state === &#39;pending&#39;)&#123;            typeof onFulfilled === &#39;function&#39; &amp;&amp; this.onFulfilled.push(onFulfilled);            typeof onRejected === &#39;function&#39; &amp;&amp; this.onRejected.push(onRejected);        &#125;    &#125;&#125;</code></pre><h3 id="function进阶版"><a href="#function进阶版" class="headerlink" title="function进阶版"></a>function进阶版</h3><pre><code class="JavaScript">const PENDING = &quot;pending&quot;; const FULFILLED = &quot;fulfilled&quot;; const REJECTED = &quot;rejected&quot;;function Promise(excutor) &#123;  let that = this; // 缓存当前promise实例例对象  that.status = PENDING; // 初始状态  that.value = undefined; // fulfilled状态时 返回的信息  that.reason = undefined; // rejected状态时 拒绝的原因   that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数  function resolve(value) &#123; // value成功态时接收的终值    if(value instanceof Promise) &#123;      return value.then(resolve, reject);    &#125;    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。    setTimeout(() =&gt; &#123;      // 调⽤用resolve 回调对应onFulfilled函数      if (that.status === PENDING) &#123;        // 只能由pending状态 =&gt; fulfilled状态 (避免调⽤用多次resolve reject)        that.status = FULFILLED;        that.value = value;        that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));      &#125;    &#125;);  &#125;  function reject(reason) &#123; // reason失败态时接收的拒因    setTimeout(() =&gt; &#123;      // 调⽤用reject 回调对应onRejected函数      if (that.status === PENDING) &#123;        // 只能由pending状态 =&gt; rejected状态 (避免调⽤用多次resolve reject)        that.status = REJECTED;        that.reason = reason;        that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));      &#125;    &#125;);  &#125;  // 捕获在excutor执⾏行行器器中抛出的异常  // new Promise((resolve, reject) =&gt; &#123;  //     throw new Error(&#39;error in excutor&#39;)  // &#125;)  try &#123;    excutor(resolve, reject);  &#125; catch (e) &#123;    reject(e);  &#125;&#125;Promise.prototype.then = function(onFulfilled, onRejected) &#123;  const that = this;  let newPromise;  // 处理理参数默认值 保证参数后续能够继续执⾏行行  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;  onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123;    throw reason;  &#125;;  if (that.status === FULFILLED) &#123; // 成功态    return newPromise = new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        try&#123;          let x = onFulfilled(that.value);          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值        &#125; catch(e) &#123;          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);        &#125;      &#125;);    &#125;)  &#125;  if (that.status === REJECTED) &#123; // 失败态    return newPromise = new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        try &#123;          let x = onRejected(that.reason);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);    &#125;);  &#125;  if (that.status === PENDING) &#123; // 等待态// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中    return newPromise = new Promise((resolve, reject) =&gt; &#123;      that.onFulfilledCallbacks.push((value) =&gt; &#123;        try &#123;          let x = onFulfilled(value);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);      that.onRejectedCallbacks.push((reason) =&gt; &#123;        try &#123;          let x = onRejected(reason);          resolvePromise(newPromise, x, resolve, reject);        &#125; catch(e) &#123;          reject(e);        &#125;      &#125;);    &#125;);  &#125;&#125;;</code></pre><hr><p>参考文档:<a href="https://blog.csdn.net/MFWSCQ/article/details/108382519">CSDN文章: Promise 的特性、优缺点，内部是如何实现的，动手实现 Promise</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-路由两种模式及其区别</title>
      <link href="2021/03/03/%E5%89%8D%E7%AB%AF/vue/vue-%E8%B7%AF%E7%94%B1%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/03/%E5%89%8D%E7%AB%AF/vue/vue-%E8%B7%AF%E7%94%B1%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue-router 有 3 种路由模式：hash、history、abstract。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="1-hash模式：hash-hashChange"><a href="#1-hash模式：hash-hashChange" class="headerlink" title="1) hash模式：hash + hashChange"></a>1) hash模式：hash + hashChange</h3><p>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。通过监听 hash（#）的变化来执行js代码 从而实现 页面的改变。 </p><p>核心代码：</p><pre><code class="javascript">window.addEventListener(‘hashchange‘,function()&#123;  self.urlChange()&#125;)</code></pre><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li><p>hash 虽然出现在 url 中，但不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面。</p></li><li><p>可以为 hash 的改变添加监听事件：</p><pre><code class="javascript">window.addEventListener(&quot;hashchange&quot;,funcRef,false)</code></pre></li><li><p>每一次改变 hash(window.localtion.hash)，都会在浏览器访问历史中增加一个记录。</p><p>利用 hash 的以上特点，就可以来实现前端路由”更新视图但不重新请求页面”的功能了。</p><p><strong>HashHistory</strong> 拥有两个方法，一个是 <strong>push</strong>， 一个是 <strong>replace</strong></p><p>即：<strong>HashHistory.push()</strong> 和 <strong>HashHistory.replace()</strong></p></li></ol><h3 id="2-history模式：historyApi-popState"><a href="#2-history模式：historyApi-popState" class="headerlink" title="2) history模式：historyApi + popState"></a>2) history模式：historyApi + popState</h3><p>HTML5推出的history API，由pushState()记录操作历史，监听popstate事件来监听到状态变更；</p><p>因为 只要刷新 这个url（<a href="http://www.ff.ff/jjkj/fdfd/fdf/fd%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E7%84%B6%E8%80%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%A0%B9%E6%9C%AC%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%8C%E6%89%80%E4%BB%A5%E5%B0%B1%E4%BC%9A%E6%8A%A5404%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%B0%B1">www.ff.ff/jjkj/fdfd/fdf/fd）就会请求服务器，然而服务器上根本没有这个资源，所以就会报404，解决方案就</a> 配置一下服务器端。</p><p>　<strong>History interface</strong> 是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p><p>　从 HTML5开始，<strong>History interface</strong> 提供了2个新的方法：pushState()、replaceState() 使得我们可以对浏览器历史记录栈进行修改：</p><pre><code class="JavaScript">　　window.history.pushState(stateObject,title,url)　　window.history,replaceState(stateObject,title,url)</code></pre><p>​        stateObject：当浏览器跳转到新的状态时，将触发 Popstate 事件，该事件将携带这个 stateObject 参数的副本</p><p>　　　　title：所添加记录的标题</p><p>　　　　  url：所添加记录的 url``</p><p>　　　　这<code>2</code>个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前<code>url</code>改变了，但浏览器不会立即发送请求该<code>url</code>，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础</p><ol><li><p>push</p><p> 与hash模式类似，只是将window.hash改为history.pushState</p></li><li><p>replace</p><p>与hash模式类似，只是将window.replace改为history.replaceState</p></li><li><p>监听地址变化</p><p>在HTML5History的构造函数中监听popState（window.onpopstate）</p></li></ol><p>说明：</p><ol><li><p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p></li><li><p>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p></li><li><p>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></li></ol><hr><p>参考文档:<a href="https://www.cnblogs.com/gaosirs/p/10606266.html">博客园文章:Vue Router 路由实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-New一个函数和直接调用的区别</title>
      <link href="2021/03/03/%E5%89%8D%E7%AB%AF/JavaScript/js-New%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/03/%E5%89%8D%E7%AB%AF/JavaScript/js-New%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用New是构造函数，不使用New是函数调用，同时this指向不同。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><pre><code class="javascript">function Test(name, age, job) &#123;　　console.log(this);　　this.name = name;　　this.age = age;　　this.job = job;&#125;</code></pre><p>1、直接调用函数</p><pre><code class="javascript">var test1 = Test(&#39;Tom&#39;, 27, &#39;IT&#39;);//来看下test1的值：console.log(test1); // undefined</code></pre><p>　　<strong>直接调用上下文指向是window</strong></p><p>2、使用new构造函数</p><pre><code class="javascript">　　var test2 = new Test(&#39;Tom&#39;, 27, &#39;IT&#39;);　　//来看下test2的值：　　console.log(test2); 　　console.log(typeof test2); // &quot;object&quot;</code></pre><p>​    <strong>new会使执行函数的上下文指向这个函数的本身。</strong></p><p>最后得出一个猜测：</p><p><strong>如果函数返回值为常规意义上的值类型（Number、String、Boolean）时，new 函数将会返回一个该函数的实例对象，而如果函数返回一个引用类型（Object、Array、Function），虽然new函数与直接调用函数产生的结果等同，但是是两个不同的过程，一个是构造对象、一个是函数调用。</strong></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>构造函数不需要显示的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果return的是对象，则返回该对象。</p><p>下面简单介绍下，javascript中new对象的过程：如var myObj = newPerson(“aty”,25);</p><ol><li><p>创建一个空的Object对象.var obj = new Object();</p></li><li><p>将构造函数Person中this指向刚创建的obj对象</p></li><li><p>将创建的obj的__proto__指向构造函数Person的prototype。这一步是建立对象和原型直接的对应关系。firefox下通过对象的__proto__属性能够访问到原型，IE下则没有暴露出相应的属性。</p></li><li><p>执行构造函数Person()中的代码</p></li></ol><hr><p>参考文档:<a href="https://www.cnblogs.com/hyshi/p/10901211.html">博客园文章js New一个函数和直接调用的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-防抖和节流</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF/JavaScript/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF/JavaScript/js-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h4><p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg" alt="img"></p><p>一起来实现个简单的debounce~</p><p>防抖debounce代码：</p><pre><code>// 防抖function debounce(fn, wait) &#123;        var timeout = null;        return function() &#123;                if(timeout !== null)   clearTimeout(timeout);                timeout = setTimeout(fn, wait);        &#125;&#125;// 处理函数function handle() &#123;        console.log(Math.random()); &#125;// 滚动事件window.addEventListener(&#39;scroll&#39;, debounce(handle, 1000));</code></pre><p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p><p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg" alt="img"></p><p>函数节流主要有两种实现方法：时间戳和定时器。接下来分别用两种方法实现throttle~</p><p>节流throttle代码（时间戳）：</p><pre><code>var throttle = function(func, delay) &#123;            　　var prev = Date.now();            　　return function() &#123;                　　　　var context = this;                　　　　var args = arguments;                　　　　var now = Date.now();                　　　　if (now - prev &gt;= delay) &#123;                    　　　　　　func.apply(context, args);                    　　　　　　prev = Date.now();                　　　　&#125;            　　&#125;        &#125;        function handle() &#123;            　　console.log(Math.random());        &#125;        window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><p>当高频事件触发时，第一次会立即执行（给scroll事件绑定函数与真正触发事件的间隔一般大于delay，如果你非要在网页加载1000毫秒以内就去滚动网页的话，我也没办法o(╥﹏╥)o），而后再怎么频繁地触发事件，也都是每delay时间才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了 （最后一次触发事件与倒数第二次触发事件的间隔小于delay，为什么小于呢？因为大于就不叫高频了呀(<em>╹▽╹</em>)）。</p><p>节流throttle代码（定时器）：</p><pre><code>// 节流throttle代码（定时器）：var throttle = function(func, delay) &#123;                var timer = null;                return function() &#123;                        var context = this;                       var args = arguments;                        if (!timer) &#123;                                timer = setTimeout(function() &#123;                                        func.apply(context, args);                                        timer = null;                                &#125;, delay);                        &#125;                &#125;        &#125;        function handle() &#123;                console.log(Math.random());        &#125;        window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><pre><code class="javascript">//简单实现function throttle(fn,delay)&#123;    let valid = true    return function() &#123;       if(!valid)&#123;           //休息时间 暂不接客           return false        &#125;       // 工作时间，执行函数并且在间隔期内把状态位设为无效        valid = false        setTimeout(() =&gt; &#123;            fn()            valid = true;        &#125;, delay)    &#125;&#125;</code></pre><p>当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。</p><p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。</p><p>节流throttle代码（时间戳+定时器）：</p><pre><code class="javascript">// 节流throttle代码（时间戳+定时器）：var throttle = function(func, delay) &#123;         var timer = null;         var startTime = Date.now();         return function() &#123;                     var curTime = Date.now();                     var remaining = delay - (curTime - startTime);                     var context = this;                     var args = arguments;                     clearTimeout(timer);                      if (remaining &lt;= 0) &#123;                                func.apply(context, args);                                startTime = Date.now();                      &#125; else &#123;                                timer = setTimeout(func, remaining);                      &#125;          &#125;&#125;function handle() &#123;          console.log(Math.random());&#125; window.addEventListener(&#39;scroll&#39;, throttle(handle, 1000));</code></pre><p>在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining&lt;=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p><hr><p>参考文档:<a href="https://www.cnblogs.com/momo798/p/9177767.html">博客园文章js防抖和节流:</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-computed和watch的区别</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>computed和watch都是观察页面的数据变化的。</p><span id="more"></span><h4 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed :"></a><strong>计算属性computed :</strong></h4><ol><li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li><li><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p></li><li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p></li><li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法</p></li></ol><h4 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h4><ol><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p>watch支持异步；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p></li></ol><p>　　immediate：组件加载立即触发回调函数执行，</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-事件绑定原理</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Vue中通过v-on或其语法糖@指令来给元素绑定事件并且提供了事件修饰符</p><span id="more"></span><p><code>Vue</code>中通过<code>v-on</code>或其语法糖<code>@</code>指令来给元素绑定事件并且提供了事件修饰符，基本流程是进行模板编译生成<code>AST</code>，生成<code>render</code>函数后并执行得到<code>VNode</code>，<code>VNode</code>生成真实<code>DOM</code>节点或者组件时候使用<code>addEventListener</code>方法进行事件绑定。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>v-on</code>与<code>@</code>用于绑定事件监听器，事件类型由参数指定，表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略，用在普通元素上时，只能监听原生<code>DOM</code>事件，用在自定义元素组件上时，也可以监听子组件触发的自定义事件，在监听原生<code>DOM</code>事件时，方法以事件为唯一的参数，如果使用内联语句，语句可以访问一个<code>$event property：v-on:click=&quot;handle(&#39;param&#39;, $event)&quot;</code>，自<code>2.4.0</code>开始<code>v-on</code>同样支持不带参数绑定一个事件或监听器键值对的对象，注意当使用对象语法时，是不支持任何修饰器的。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>.stop</code>: 调用<code>event.stopPropagation()</code>，即阻止事件冒泡。</li><li><code>.prevent</code>: 调用<code>event.preventDefault()</code>，即阻止默认事件。</li><li><code>.capture</code>: 添加事件侦听器时使用<code>capture</code>模式，即使用事件捕获模式处理事件。</li><li><code>.self</code>: 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li><code>.&#123;keyCode | keyAlias&#125;</code>: 只当事件是从特定键触发时才触发回调。</li><li><code>.native</code>: 监听组件根元素的原生事件，即注册组件根元素的原生事件而不是组件自定义事件的。</li><li><code>.once</code>: 只触发一次回调。</li><li><code>.left(2.2.0)</code>: 只当点击鼠标左键时触发。</li><li><code>.right(2.2.0)</code>: 只当点击鼠标右键时触发。</li><li><code>.middle(2.2.0)</code>: 只当点击鼠标中键时触发。</li><li><code>.passive(2.3.0)</code>: 以<code>&#123; passive: true &#125;</code>模式添加侦听器，表示<code>listener</code>永远不会调用<code>preventDefault()</code>。</li></ul><h3 id="普通元素"><a href="#普通元素" class="headerlink" title="普通元素"></a>普通元素</h3><pre><code class="html">&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件 (2.6.0+) --&gt;&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;doThat(&#39;param&#39;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件缩写 (2.6.0+) --&gt;&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!--  串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=&quot;onEnter&quot;&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;</code></pre><h3 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h3><pre><code class="html">&lt;!-- 自定义事件 --&gt;&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event=&quot;handleThis(&#39;param&#39;, $event)&quot;&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>Vue</code>源码的实现比较复杂，会处理各种兼容问题与异常以及各种条件分支，文章分析比较核心的代码部分，精简过后的版本，重要部分做出注释，<code>commit id</code>为<code>ef56410</code>。</p><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p><code>Vue</code>在挂载实例前，有相当多的工作是进行模板的编译，将<code>template</code>模板进行编译，解析成<code>AST</code>树，再转换成<code>render</code>函数，而在编译阶段，就是对事件的指令做收集处理。<br>在<code>template</code>模板中，定义事件的部分是属于<code>XML</code>的<code>Attribute</code>，所以收集指令时需要匹配<code>Attributes</code>以确定哪个<code>Attribute</code>是属于事件。</p><pre><code class="javascript">Copy// dev/src/compiler/parser/index.js line 23export const onRE = /^@|^v-on:/export const dirRE = process.env.VBIND_PROP_SHORTHAND  ? /^v-|^@|^:|^\.|^#/  : /^v-|^@|^:|^#/// ...const dynamicArgRE = /^\[.*\]$/// ...export const bindRE = /^:|^\.|^v-bind:/  // dev/src/compiler/parser/index.js line 757function processAttrs (el) &#123;  const list = el.attrsList  let i, l, name, rawName, value, modifiers, syncGen, isDynamic  for (i = 0, l = list.length; i &lt; l; i++) &#123;    name = rawName = list[i].name    value = list[i].value    if (dirRE.test(name)) &#123; // 匹配指令属性      // mark element as dynamic      el.hasBindings = true      // modifiers      modifiers = parseModifiers(name.replace(dirRE, &#39;&#39;)) // 将修饰符解析      // support .foo shorthand syntax for the .prop modifier      if (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) &#123;        (modifiers || (modifiers = &#123;&#125;)).prop = true        name = `.` + name.slice(1).replace(modifierRE, &#39;&#39;)      &#125; else if (modifiers) &#123;        name = name.replace(modifierRE, &#39;&#39;)      &#125;      if (bindRE.test(name)) &#123; // v-bind // 处理v-bind的情况        // ...      &#125; else if (onRE.test(name)) &#123; // v-on // 处理事件绑定        name = name.replace(onRE, &#39;&#39;) // 将事件名匹配        isDynamic = dynamicArgRE.test(name) // 动态事件绑定        if (isDynamic) &#123; // 如果是动态事件          name = name.slice(1, -1) // 去掉两端的 []        &#125;        addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic) // 处理事件收集      &#125; else &#123; // normal directives // 处理其他指令        // ...      &#125;    &#125; else &#123;      // literal attribute // 处理文字属性      // ...    &#125;  &#125;&#125;</code></pre><p>通过<code>addHandler</code>方法，为<code>AST</code>树添加事件相关的属性以及对事件修饰符进行处理。</p><pre><code class="javascript">// dev/src/compiler/helpers.js line 69export function addHandler (  el: ASTElement,  name: string,  value: string,  modifiers: ?ASTModifiers,  important?: boolean,  warn?: ?Function,  range?: Range,  dynamic?: boolean) &#123;  modifiers = modifiers || emptyObject  // passive 和 prevent 不能同时使用，具体是由passive模式的性质决定的  // 详细可以参阅 https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener  // warn prevent and passive modifier  /* istanbul ignore if */  if (    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn &amp;&amp;    modifiers.prevent &amp;&amp; modifiers.passive  ) &#123;    warn(      &#39;passive and prevent can\&#39;t be used together. &#39; +      &#39;Passive handler can\&#39;t prevent default event.&#39;,      range    )  &#125;  // 标准化click.right和click.middle，因为它们实际上不会触发。  // 从技术上讲，这是特定于浏览器的，但是至少目前来说，浏览器是唯一具有右键/中间点击的目标环境。  // normalize click.right and click.middle since they don&#39;t actually fire  // this is technically browser-specific, but at least for now browsers are  // the only target envs that have right/middle clicks.  if (modifiers.right) &#123; // 将鼠标右键点击标准化 右键点击默认的是 contextmenu 事件    if (dynamic) &#123; // 如果是动态事件      name = `($&#123;name&#125;)===&#39;click&#39;?&#39;contextmenu&#39;:($&#123;name&#125;)` // 动态确定事件名    &#125; else if (name === &#39;click&#39;) &#123; // 如果不是动态事件且是鼠标右击      name = &#39;contextmenu&#39; // 则直接替换为contextmenu事件      delete modifiers.right // 删除modifiers的right属性    &#125;  &#125; else if (modifiers.middle) &#123; // 同样标准化处理鼠标中键点击的事件    if (dynamic) &#123; // 如果是动态事件      name = `($&#123;name&#125;)===&#39;click&#39;?&#39;mouseup&#39;:($&#123;name&#125;)` // 动态确定事件名    &#125; else if (name === &#39;click&#39;) &#123; // 如果不是动态事件且是鼠标中键点击      name = &#39;mouseup&#39; // 处理为mouseup事件    &#125;  &#125;  // 下面是对捕获、一次触发、passive模式的modifiers处理，主要是为事件添加 !、~、&amp; 标记  // 这一部分标记可以在Vue官方文档中查阅   // https://cn.vuejs.org/v2/guide/render-function.html#%E4%BA%8B%E4%BB%B6-amp-%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6  // check capture modifier  if (modifiers.capture) &#123;    delete modifiers.capture    name = prependModifierMarker(&#39;!&#39;, name, dynamic)  &#125;  if (modifiers.once) &#123;    delete modifiers.once    name = prependModifierMarker(&#39;~&#39;, name, dynamic)  &#125;  /* istanbul ignore if */  if (modifiers.passive) &#123;    delete modifiers.passive    name = prependModifierMarker(&#39;&amp;&#39;, name, dynamic)  &#125;    // events 用来记录绑定的事件  let events  if (modifiers.native) &#123; // 如果是要触发根元素原生事件则直接取得nativeEvents    delete modifiers.native    events = el.nativeEvents || (el.nativeEvents = &#123;&#125;)  &#125; else &#123; // 否则取得events    events = el.events || (el.events = &#123;&#125;)  &#125;      // 将事件处理函数作为handler  const newHandler: any = rangeSetItem(&#123; value: value.trim(), dynamic &#125;, range)  if (modifiers !== emptyObject) &#123;    newHandler.modifiers = modifiers  &#125; // 绑定的事件可以多个，回调也可以多个，最终会合并到数组中  const handlers = events[name]  /* istanbul ignore if */  if (Array.isArray(handlers)) &#123;    important ? handlers.unshift(newHandler) : handlers.push(newHandler)  &#125; else if (handlers) &#123;    events[name] = important ? [newHandler, handlers] : [handlers, newHandler]  &#125; else &#123;    events[name] = newHandler  &#125;  el.plain = false&#125;</code></pre><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>接下来需要将<code>AST</code>语法树转<code>render</code>函数，在这个过程中会加入对事件的处理，首先模块导出了<code>generate</code>函数，<code>generate</code>函数即会返回<code>render</code>字符串，在这之前会调用<code>genElement</code>函数，而在上述<code>addHandler</code>方法处理的最后执行了<code>el.plain = false</code>，这样在<code>genElement</code>函数中会调用<code>genData</code>函数，而在<code>genData</code>函数中即会调用<code>genHandlers</code>函数。</p><pre><code class="javascript">// dev/src/compiler/codegen/index.js line 42export function generate (  ast: ASTElement | void,  options: CompilerOptions): CodegenResult &#123;  const state = new CodegenState(options)  const code = ast ? genElement(ast, state) : &#39;_c(&quot;div&quot;)&#39;  return &#123;    render: `with(this)&#123;return $&#123;code&#125;&#125;`, // 即render字符串    staticRenderFns: state.staticRenderFns  &#125;&#125;// dev/src/compiler/codegen/index.js line 55export function genElement (el: ASTElement, state: CodegenState): string &#123;    // ...    let code    if (el.component) &#123;      code = genComponent(el.component, el, state)    &#125; else &#123;      let data      if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;        data = genData(el, state)      &#125;      const children = el.inlineTemplate ? null : genChildren(el, state, true)      code = `_c(&#39;$&#123;el.tag&#125;&#39;$&#123;        data ? `,$&#123;data&#125;` : &#39;&#39; // data      &#125;$&#123;        children ? `,$&#123;children&#125;` : &#39;&#39; // children      &#125;)`    &#125;    // ...&#125;// dev/src/compiler/codegen/index.js line 219export function genData (el: ASTElement, state: CodegenState): string &#123;  let data = &#39;&#123;&#39;  // ...  // event handlers  if (el.events) &#123;    data += `$&#123;genHandlers(el.events, false)&#125;,`  &#125;  if (el.nativeEvents) &#123;    data += `$&#123;genHandlers(el.nativeEvents, true)&#125;,`  &#125;  // ...  data = data.replace(/,$/, &#39;&#39;) + &#39;&#125;&#39;  // ...  return data&#125;// dev/src/compiler/to-function.js line 12 function createFunction (code, errors) &#123;  try &#123;    return new Function(code) // 将render字符串转为render函数  &#125; catch (err) &#123;    errors.push(&#123; err, code &#125;)    return noop  &#125;&#125;</code></pre><p>可以看到无论是处理普通元素事件还是组件根元素原生事件都会调用<code>genHandlers</code>函数，<code>genHandlers</code>函数即会遍历解析好的<code>AST</code>树中事件属性，拿到<code>event</code>对象属性，并根据属性上的事件对象拼接成字符串。</p><pre><code class="javascript">// dev/src/compiler/codegen/events.js line 3const fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=&gt;|^function(?:\s+[\w$]+)?\s*\(/const fnInvokeRE = /\([^)]*?\);*$/const simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[&#39;[^&#39;]*?&#39;]|\[&quot;[^&quot;]*?&quot;]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/// dev/src/compiler/codegen/events.js line 7// KeyboardEvent.keyCode aliasesconst keyCodes: &#123; [key: string]: number | Array&lt;number&gt; &#125; = &#123;  esc: 27,  tab: 9,  enter: 13,  space: 32,  up: 38,  left: 37,  right: 39,  down: 40,  &#39;delete&#39;: [8, 46]&#125;// KeyboardEvent.key aliasesconst keyNames: &#123; [key: string]: string | Array&lt;string&gt; &#125; = &#123;  // #7880: IE11 and Edge use `Esc` for Escape key name.  esc: [&#39;Esc&#39;, &#39;Escape&#39;],  tab: &#39;Tab&#39;,  enter: &#39;Enter&#39;,  // #9112: IE11 uses `Spacebar` for Space key name.  space: [&#39; &#39;, &#39;Spacebar&#39;],  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.  up: [&#39;Up&#39;, &#39;ArrowUp&#39;],  left: [&#39;Left&#39;, &#39;ArrowLeft&#39;],  right: [&#39;Right&#39;, &#39;ArrowRight&#39;],  down: [&#39;Down&#39;, &#39;ArrowDown&#39;],  // #9112: IE11 uses `Del` for Delete key name.  &#39;delete&#39;: [&#39;Backspace&#39;, &#39;Delete&#39;, &#39;Del&#39;]&#125;&#125;// dev/src/compiler/codegen/events.js line 37// #4868: modifiers that prevent the execution of the listener// need to explicitly return null so that we can determine whether to remove// the listener for .onceconst genGuard = condition =&gt; `if($&#123;condition&#125;)return null;`const modifierCode: &#123; [key: string]: string &#125; = &#123;  stop: &#39;$event.stopPropagation();&#39;,  prevent: &#39;$event.preventDefault();&#39;,  self: genGuard(`$event.target !== $event.currentTarget`),  ctrl: genGuard(`!$event.ctrlKey`),  shift: genGuard(`!$event.shiftKey`),  alt: genGuard(`!$event.altKey`),  meta: genGuard(`!$event.metaKey`),  left: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 0`),  middle: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 1`),  right: genGuard(`&#39;button&#39; in $event &amp;&amp; $event.button !== 2`)&#125;// dev/src/compiler/codegen/events.js line 55export function genHandlers (  events: ASTElementHandlers,  isNative: boolean): string &#123;  const prefix = isNative ? &#39;nativeOn:&#39; : &#39;on:&#39;  let staticHandlers = ``  let dynamicHandlers = ``  for (const name in events) &#123; // 遍历AST解析后的事件属性    const handlerCode = genHandler(events[name]) // 将事件对象转换成可拼接的字符串    if (events[name] &amp;&amp; events[name].dynamic) &#123;      dynamicHandlers += `$&#123;name&#125;,$&#123;handlerCode&#125;,`    &#125; else &#123;      staticHandlers += `&quot;$&#123;name&#125;&quot;:$&#123;handlerCode&#125;,`    &#125;  &#125;  staticHandlers = `&#123;$&#123;staticHandlers.slice(0, -1)&#125;&#125;`  if (dynamicHandlers) &#123;    return prefix + `_d($&#123;staticHandlers&#125;,[$&#123;dynamicHandlers.slice(0, -1)&#125;])`  &#125; else &#123;    return prefix + staticHandlers  &#125;&#125;// dev/src/compiler/codegen/events.js line 96function genHandler (handler: ASTElementHandler | Array&lt;ASTElementHandler&gt;): string &#123;  if (!handler) &#123;    return &#39;function()&#123;&#125;&#39;  &#125;  // 事件绑定可以多个，多个在解析AST树时会以数组的形式存在，如果有多个则会递归调用getHandler方法返回数组。  if (Array.isArray(handler)) &#123;    return `[$&#123;handler.map(handler =&gt; genHandler(handler)).join(&#39;,&#39;)&#125;]`  &#125;  const isMethodPath = simplePathRE.test(handler.value) // 调用方法为 doThis 型  const isFunctionExpression = fnExpRE.test(handler.value) // 调用方法为 () =&gt; &#123;&#125; or function() &#123;&#125; 型  const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, &#39;&#39;)) // 调用方法为 doThis($event) 型  if (!handler.modifiers) &#123; // 没有修饰符    if (isMethodPath || isFunctionExpression) &#123; // 符合这两个条件则直接返回      return handler.value    &#125;    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; handler.params) &#123;      return genWeexHandler(handler.params, handler.value)    &#125;    return `function($event)&#123;$&#123; // 返回拼接的匿名函数的字符串      isFunctionInvocation ? `return $&#123;handler.value&#125;` : handler.value    &#125;&#125;` // inline statement  &#125; else &#123; // 处理具有修饰符的情况    let code = &#39;&#39;    let genModifierCode = &#39;&#39;    const keys = []    for (const key in handler.modifiers) &#123;  // 遍历modifiers上记录的修饰符      if (modifierCode[key]) &#123;        genModifierCode += modifierCode[key]  // 根据修饰符添加对应js的代码        // left/right        if (keyCodes[key]) &#123;          keys.push(key)        &#125;      &#125; else if (key === &#39;exact&#39;) &#123; // 针对exact的处理        const modifiers: ASTModifiers = (handler.modifiers: any)        genModifierCode += genGuard(          [&#39;ctrl&#39;, &#39;shift&#39;, &#39;alt&#39;, &#39;meta&#39;]            .filter(keyModifier =&gt; !modifiers[keyModifier])            .map(keyModifier =&gt; `$event.$&#123;keyModifier&#125;Key`)            .join(&#39;||&#39;)        )      &#125; else &#123;        keys.push(key) // 如果修饰符不是以上修饰符，则会添加到keys数组中      &#125;    &#125;    if (keys.length) &#123;      code += genKeyFilter(keys) // 处理其他修饰符 即keyCodes中定义的修饰符    &#125;    // Make sure modifiers like prevent and stop get executed after key filtering    if (genModifierCode) &#123;      code += genModifierCode    &#125;    // 根据三种不同的书写模板返回不同的字符串    const handlerCode = isMethodPath      ? `return $&#123;handler.value&#125;($event)`      : isFunctionExpression        ? `return ($&#123;handler.value&#125;)($event)`        : isFunctionInvocation          ? `return $&#123;handler.value&#125;`          : handler.value    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; handler.params) &#123;      return genWeexHandler(handler.params, code + handlerCode)    &#125;    return `function($event)&#123;$&#123;code&#125;$&#123;handlerCode&#125;&#125;`  &#125;&#125;// dev/src/compiler/codegen/events.js line 175function genFilterCode (key: string): string &#123;  const keyVal = parseInt(key, 10)  if (keyVal) &#123; // 如果key是数字，则直接返回$event.keyCode!==$&#123;keyVal&#125;    return `$event.keyCode!==$&#123;keyVal&#125;`  &#125;  const keyCode = keyCodes[key]  const keyName = keyNames[key]  // 返回_k函数，它的第一个参数是$event.keyCode，  // 第二个参数是key的值，  // 第三个参数就是key在keyCodes中对应的数字。  return (    `_k($event.keyCode,` +    `$&#123;JSON.stringify(key)&#125;,` +    `$&#123;JSON.stringify(keyCode)&#125;,` +    `$event.key,` +    `$&#123;JSON.stringify(keyName)&#125;` +    `)`  )&#125;</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>前面介绍了如何编译模板提取事件收集指令以及生成<code>render</code>字符串和<code>render</code>函数，但是事件真正的绑定到<code>DOM</code>上还是离不开事件注册，此阶段就发生在<code>patchVnode</code>过程中，在生成完成<code>VNode</code>后，进行<code>patchVnode</code>过程中创建真实<code>DOM</code>时会进行事件注册的相关钩子处理。</p><pre><code class="javascript">// dev/src/core/vdom/patch.js line 33const hooks = [&#39;create&#39;, &#39;activate&#39;, &#39;update&#39;, &#39;remove&#39;, &#39;destroy&#39;]// dev/src/core/vdom/patch.js line 125function createElm (    vnode,    insertedVnodeQueue,    parentElm,    refElm,    nested,    ownerArray,    index  ) &#123;  // ...  if (isDef(data)) &#123;    invokeCreateHooks(vnode, insertedVnodeQueue)  &#125;  // ...&#125;// dev/src/core/vdom/patch.js line 303// 在之前cbs经过处理 // 这里cbs.create包含如下几个回调：// updateAttrs、updateClass、updateDOMListeners、updateDOMProps、updateStyle、update、updateDirectivesfunction invokeCreateHooks (vnode, insertedVnodeQueue) &#123;    for (let i = 0; i &lt; cbs.create.length; ++i) &#123;      cbs.create[i](emptyNode, vnode)    &#125;    i = vnode.data.hook // Reuse variable    if (isDef(i)) &#123;      if (isDef(i.create)) i.create(emptyNode, vnode)      if (isDef(i.insert)) insertedVnodeQueue.push(vnode)    &#125;&#125;</code></pre><p><code>invokeCreateHooks</code>就是一个模板指令处理的任务，他分别针对不同的指令为真实阶段创建不同的任务，针对事件，这里会调<code>updateDOMListeners</code>对真实的<code>DOM</code>节点注册事件任务。</p><pre><code class="javascript">// dev/src/platforms/web/runtime/modules/events.js line 105function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) &#123;  if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123;  // on是事件指令的标志    return  &#125;  // 新旧节点不同的事件绑定解绑  const on = vnode.data.on || &#123;&#125;  const oldOn = oldVnode.data.on || &#123;&#125;  // 拿到需要添加事件的真实DOM节点  target = vnode.elm  // normalizeEvents是对事件兼容性的处理  normalizeEvents(on)  // 调用updateListeners方法，并将on作为参数传进去  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)  target = undefined&#125;// dev/src/core/vdom/helpers/update-listeners.js line line 53export function updateListeners (  on: Object,  oldOn: Object,  add: Function,  remove: Function,  createOnceHandler: Function,  vm: Component) &#123;  let name, def, cur, old, event  for (name in on) &#123; // 遍历事件    def = cur = on[name]    old = oldOn[name]    event = normalizeEvent(name)    /* istanbul ignore if */    if (__WEEX__ &amp;&amp; isPlainObject(def)) &#123;      cur = def.handler      event.params = def.params    &#125;    if (isUndef(cur)) &#123; // 事件名非法的报错处理      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(        `Invalid handler for event &quot;$&#123;event.name&#125;&quot;: got ` + String(cur),        vm      )    &#125; else if (isUndef(old)) &#123; // 旧节点不存在      if (isUndef(cur.fns)) &#123; // createFunInvoker返回事件最终执行的回调函数        cur = on[name] = createFnInvoker(cur, vm)      &#125;      if (isTrue(event.once)) &#123;  // 只触发一次的事件        cur = on[name] = createOnceHandler(event.name, cur, event.capture)      &#125;      // 执行真正注册事件的执行函数      add(event.name, cur, event.capture, event.passive, event.params)    &#125; else if (cur !== old) &#123;      old.fns = cur      on[name] = old    &#125;  &#125;  for (name in oldOn) &#123; // 旧节点存在，解除旧节点上的绑定事件    if (isUndef(on[name])) &#123;      event = normalizeEvent(name)      // 移除事件监听      remove(event.name, oldOn[name], event.capture)    &#125;  &#125;&#125;// dev/src/platforms/web/runtime/modules/events.js line 32// 在执行完回调之后，移除事件绑定function createOnceHandler (event, handler, capture) &#123;  const _target = target // save current target element in closure  return function onceHandler () &#123;    const res = handler.apply(null, arguments)    if (res !== null) &#123;      remove(event, onceHandler, capture, _target)    &#125;  &#125;&#125;</code></pre><p>最终添加与移除事件都是调用的<code>add</code>与<code>remove</code>方法，最终调用的方法即<code>DOM</code>的<code>addEventListener</code>方法与<code>removeEventListener</code>方法。</p><pre><code class="javascript">// dev/src/platforms/web/runtime/modules/events.js line 46function add (  name: string,  handler: Function,  capture: boolean,  passive: boolean) &#123;  // async edge case #6566: inner click event triggers patch, event handler  // attached to outer element during patch, and triggered again. This  // happens because browsers fire microtask ticks between event propagation.  // the solution is simple: we save the timestamp when a handler is attached,  // and the handler would only fire if the event passed to it was fired  // AFTER it was attached.  if (useMicrotaskFix) &#123;    const attachedTimestamp = currentFlushTimestamp    const original = handler    handler = original._wrapper = function (e) &#123;      if (        // no bubbling, should always fire.        // this is just a safety net in case event.timeStamp is unreliable in        // certain weird environments...        e.target === e.currentTarget ||        // event is fired after handler attachment        e.timeStamp &gt;= attachedTimestamp ||        // bail for environments that have buggy event.timeStamp implementations        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState        // #9681 QtWebEngine event.timeStamp is negative value        e.timeStamp &lt;= 0 ||        // #9448 bail if event is fired in another document in a multi-page        // electron/nw.js app, since event.timeStamp will be using a different        // starting reference        e.target.ownerDocument !== document      ) &#123;        return original.apply(this, arguments)      &#125;    &#125;  &#125;  target.addEventListener(    name,    handler,    supportsPassive      ? &#123; capture, passive &#125;      : capture  )&#125;// dev/src/platforms/web/runtime/modules/events.js line 92function remove (  name: string,  handler: Function,  capture: boolean,  _target?: HTMLElement) &#123;  (_target || target).removeEventListener(    name,    handler._wrapper || handler,    capture  )&#125;</code></pre><hr><p>参考文档:<a href="https://www.cnblogs.com/WindrunnerMax/p/13629209.html">博客园文章:Vue事件绑定原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-生命周期</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF/vue/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。</p><span id="more"></span><h2 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h2><h4 id="1､创建前-后："><a href="#1､创建前-后：" class="headerlink" title="1､创建前/后："></a><strong>1､创建前/后：</strong></h4><h5 id="1-beforeCreate阶段："><a href="#1-beforeCreate阶段：" class="headerlink" title="1) beforeCreate阶段："></a>1) beforeCreate阶段：</h5><p>vue实例的挂载元素el和数据对象data都为undefined，还未初始化。</p><p>说明：在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p><h5 id="2-created阶段："><a href="#2-created阶段：" class="headerlink" title="2) created阶段："></a>2) created阶段：</h5><p>vue实例的数据对象data有了，el还没有。</p><p>说明：可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p><h4 id="2､载入前-后："><a href="#2､载入前-后：" class="headerlink" title="2､载入前/后："></a><strong>2､载入前/后：</strong></h4><h5 id="1-beforeMount阶段："><a href="#1-beforeMount阶段：" class="headerlink" title="1) beforeMount阶段："></a>1) beforeMount阶段：</h5><p>vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点。</p><p>说明：当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p><h5 id="2-mounted阶段："><a href="#2-mounted阶段：" class="headerlink" title="2) mounted阶段："></a>2) mounted阶段：</h5><p>vue实例挂载完成，data.message成功渲染。</p><p>说明：在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p><h4 id="3､更新前-后："><a href="#3､更新前-后：" class="headerlink" title="3､更新前/后："></a><strong>3､更新前/后</strong>：</h4><h5 id="1-beforeUpdate阶段："><a href="#1-beforeUpdate阶段：" class="headerlink" title="1) beforeUpdate阶段："></a>1) beforeUpdate阶段：</h5><p>响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器。</p><p>说明：可以在当前阶段进行更改数据，不会造成重渲染。</p><h5 id="2-updated阶段："><a href="#2-updated阶段：" class="headerlink" title="2) updated阶段："></a>2) updated阶段：</h5><p>虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环。</p><p>说明：当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><h4 id="4､销毁前-后："><a href="#4､销毁前-后：" class="headerlink" title="4､销毁前/后："></a><strong>4､销毁前/后</strong>：</h4><h5 id="1-beforeDestroy阶段："><a href="#1-beforeDestroy阶段：" class="headerlink" title="1) beforeDestroy阶段："></a>1) beforeDestroy阶段：</h5><p>实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件。</p><p>说明：在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><h5 id="2-destroyed阶段："><a href="#2-destroyed阶段：" class="headerlink" title="2) destroyed阶段："></a>2) destroyed阶段：</h5><p>实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁。</p><p>说明：当前阶段组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><h4 id="补充回答："><a href="#补充回答：" class="headerlink" title="补充回答："></a>补充回答：</h4><p>第一次页面加载时会触发：beforeCreate, created, beforeMount, mounted。</p><ol><li><p> created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。(服务器渲染支持created方法)</p></li><li><p> mounted 实例已经挂载完成，可以进行一些DOM操作。(接口请求)</p></li></ol><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js">https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-{}与new Object()的区别是什么?</title>
      <link href="2021/02/25/%E5%89%8D%E7%AB%AF/JavaScript/js-%7B%7D%E4%B8%8Enew%20Object()%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2021/02/25/%E5%89%8D%E7%AB%AF/JavaScript/js-%7B%7D%E4%B8%8Enew%20Object()%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>{} 这个叫做对象字面量,new Object()中没有传入参数，与{}是一样的</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="javascript">var a = &#123;&#125;;var b = new Object();</code></pre><p>这两种创建对象方式,从测试效果来看，{}会快一点。</p><p>{} 这个叫做对象字面量</p><p>如果new Object()中没有传入参数，与{}是一样的。</p><p>但是如果传入不同的参数，会有不同的效果。</p><p>传入String 返回String，类似new String()</p><p>传入Number 返回Number，类似new Number()</p><p>传入Object 返回Object，其实没啥用</p><pre><code class="javascript">var Obj = function() &#123;&#125;;var a = &#123;&#125;;var b = new Object();var c = new Obj();</code></pre><p> c最快，a次之，b最慢</p><p>一般来说,{}是字面量，可以立即求值，而new Object()本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/5d7fe194649e">简书文章:{}与new Object()的区别是什么?</a></p><p>扩展阅读:<a href="https://www.jb51.net/article/129589.htm">脚本之家文章:new Array()和var arr=[]用法区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-prototype和__proto__</title>
      <link href="2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-prototype%E5%92%8C__proto__/"/>
      <url>2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-prototype%E5%92%8C__proto__/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>prototype是函数才有的属性;__proto__是每个对象都有的属性</p><span id="more"></span><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>JavaScript的原型是一个很让人头疼的事情，一来<code>prototype</code>容易与<code>__proto__</code>混淆，二来它们之间的各种指向实在有些复杂，(关键Function和Object的关系复杂，他们的关系，可以阅读一下这篇文章<a href="https://www.jianshu.com/p/5727780214ac">这篇文章</a>)。<br> 原型是一个对象，其他对象可以通过它实现属性继承。</p><pre><code class="jsx"> let obj = Object.create(Object.prototype);console.log(obj);</code></pre><h4 id="2、prototype和-proto-的区别"><a href="#2、prototype和-proto-的区别" class="headerlink" title="2、prototype和__proto__的区别"></a>2、prototype和__proto__的区别</h4><h5 id="prototype是函数才有的属性，切记，切记"><a href="#prototype是函数才有的属性，切记，切记" class="headerlink" title="prototype是函数才有的属性，切记，切记"></a>prototype是函数才有的属性，切记，切记</h5><p>具体原因，可以看看阮一峰大神的这篇文章<a href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a>，里面介绍了<code>prototype</code>的设计由来。</p><h5 id="proto-是每个对象都有的属性"><a href="#proto-是每个对象都有的属性" class="headerlink" title="__proto__是每个对象都有的属性"></a><code>__proto__</code>是每个对象都有的属性</h5><p>它不是一个规范属性，该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它。<code>__proto__</code>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用<code>Object.getPrototypeOf/Reflect.getPrototypeOf</code>和<code>Object.setPrototypeOf/Reflect.setPrototypeOf</code>。<br> <strong>注意：大多数情况下，<code>__proto__</code>可以理解为“构造器的原型”，即<code>__proto__</code>===<code>constructor.prototype</code>,但是通过 Object.create()创建的对象有可能不是， Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>，下面会有实例解释</strong></p><pre><code class="jsx">      let obj =｛｝;      console.log(&quot;obj:&quot;, obj);      console.log(&quot;obj.prototype:&quot;, obj.prototype);      console.log(&quot;obj.__proto__:&quot;, obj.__proto__);      console.log(&quot;====================================&quot;);      function myFunc() &#123;&#125;      console.log(&quot;myFunc.prototype:&quot;,myFunc.prototype);      console.log(&quot;myFunc.__proto__:&quot;,myFunc.__proto__);</code></pre><p>打印出的结果很容易就证明上面的结论了。([native code] 指的是底层代码)</p><h4 id="3、-proto-指向"><a href="#3、-proto-指向" class="headerlink" title="3、__proto__指向"></a>3、__proto__指向</h4><p><code>__proto__</code>是每个对象有的属性，那我们就从对象下手，我们列举几种常见创建对象的方式，来看看他们的<code>__proto__</code>指向。</p><h5 id="1、字面量方式"><a href="#1、字面量方式" class="headerlink" title="1、字面量方式"></a>1、字面量方式</h5><pre><code class="tsx">    let obj = &#123;&#125;;    console.log(&quot;obj.__proto__:&quot;, obj.__proto__);    console.log( obj.__proto__===obj.constructor.prototype);</code></pre><h5 id="2、构造器"><a href="#2、构造器" class="headerlink" title="2、构造器"></a>2、构造器</h5><pre><code class="tsx">      let objP = function() &#123;&#125;;      let obj = new objP();      console.log(&quot;obj.__proto__:&quot;, obj.__proto__);      console.log(obj.__proto__ === obj.constructor.prototype);      let objO = new Object();      console.log(&quot;objO.__proto__:&quot;, objO.__proto__);      console.log(objO.__proto__ === objO.constructor.prototype);</code></pre><h5 id="3、-Object-create"><a href="#3、-Object-create" class="headerlink" title="3、 Object.create()"></a>3、 Object.create()</h5><pre><code class="tsx">      let a1 = &#123; a: 1 &#125;;      let a2 = Object.create(a1);      console.log(&quot;a2.__proto__:&quot;,a2.__proto__); //Object &#123;a: 1&#125;      console.log(a2.__proto__ === a1.constructor.prototype); //false      let a3 = Object.create(a1.__proto__);      console.log(&quot;a3.__proto__&quot;,a3.__proto__);       console.log(a3.__proto__ === a1.constructor.prototype); //true</code></pre><p> 从结果可以看到，第二部分中的结论，大多数情况下，<code>__proto__</code>可以理解为“构造器的原型”，即<code>__proto__</code>===<code>constructor.prototype</code>,但是通过 Object.create()创建的对象有可能不是， Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/3d756c5bba16">简书文章:prototype和__proto__</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-this指向问题</title>
      <link href="2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/24/%E5%89%8D%E7%AB%AF/JavaScript/js-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>function(){} 和 () =&gt;{} 中this指向的问题</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="普通函数中this"><a href="#普通函数中this" class="headerlink" title="普通函数中this"></a>普通函数中this</h4><ol><li><p>this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj</p></li><li><p>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)</p></li><li><p>在严格模式下,没有直接调用者的函数中的this是 undefined</p></li><li><p>使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象</p></li></ol><p>注意：普通函数中，内层函数不能从外层函数中继承this的值，在内层函数中，this会是window或者undefined，临时变量self用来将外部的this值导入到内部函数中（另外的方式是在内部函数执行.bind(this)）</p><h4 id="es6箭头函数"><a href="#es6箭头函数" class="headerlink" title="es6箭头函数"></a>es6箭头函数</h4><p>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this。</p><p>当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,最后直到window,全局变量默认挂载在window对象下</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h4 id="1、普通函数中内层函数"><a href="#1、普通函数中内层函数" class="headerlink" title="1、普通函数中内层函数"></a>1、普通函数中内层函数</h4><pre><code class="js">function fun()&#123;    var self = this;    setTimeout(function()&#123;        console.log(this);// window        console.log(self);// &#123;id: 001&#125;        console.log(&#39;id: &#39;, self.id);// id:001    &#125;,500);&#125;fun.call(&#123;id:001&#125;);</code></pre><h4 id="2、普通函数中内层函数-bind-this"><a href="#2、普通函数中内层函数-bind-this" class="headerlink" title="2、普通函数中内层函数.bind(this)"></a>2、普通函数中内层函数.bind(this)</h4><pre><code class="javascript">function fun()&#123;    var self = this;    setTimeout(function()&#123;        console.log(this); //&#123;id: 1&#125;        console.log(self); //&#123;id: 1&#125;        console.log(&#39;id: &#39;, self.id); //id: 1    &#125;.bind(this),500);&#125;fun.call(&#123;id:001&#125;);</code></pre><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><pre><code class="javascript">  function Fun()&#123;    console.log(&quot;args:fun:&quot;,arguments); //args:[2,2,3,4]    setTimeout(() =&gt;&#123;      console.log(&quot;args:()=&gt;&#123;&#125;:&quot;,arguments); //args:[2,2,3,4]    &#125;,500);    setTimeout(function()&#123;      console.log(&quot;args:function()&#123;&#125;&quot;,arguments); //    &#125;,500);  &#125;  new Fun(2,2,3,4)</code></pre><h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><pre><code class="javascript">var obj = &#123;   say: function () &#123;     setTimeout(() =&gt; &#123;       console.log(this)     &#125;);   &#125; &#125; obj.say(); // obj</code></pre><h4 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  var f1 = () =&gt; &#123;    console.log(this); // obj    setTimeout(() =&gt; &#123;      console.log(this); // obj    &#125;)  &#125;  f1();  &#125;&#125;obj.say()</code></pre><h4 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  var f1 = function () &#123;    console.log(this); // window, f1调用时,没有直接调用者,也就是没有宿主对象,默认是window    setTimeout(() =&gt; &#123;      console.log(this); // window    &#125;)  &#125;;   var f2 = ()=&gt;&#123;      console.log(this); //say f2调用时,this默认指向所处的对象(宿主对象),不是执行对象   &#125;;    f1();    f2();  &#125;&#125;obj.say()</code></pre><h4 id="7、严格模式"><a href="#7、严格模式" class="headerlink" title="7、严格模式"></a>7、严格模式</h4><pre><code class="javascript">var obj = &#123;say: function () &#123;  &#39;use strict&#39;;  var f1 = function () &#123;  console.log(this); // undefined  setTimeout(() =&gt; &#123;    console.log(this); // undefined  &#125;)  &#125;;  f1(); &#125;&#125;obj.say()</code></pre><h4 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h4><pre><code class="javascript">  var a = &#39;window&#39;;  var id = &#39;1&#39;;  var obj2 = &#123;    id: &#39;2&#39;,    a: &#39;obj2&#39;  &#125;  var obj = &#123;    a: &#39;obj&#39;,    id: &#39;3&#39;,    say1: () =&gt; &#123;      console.log(this.a);      console.log(this.id);    &#125;,    say2: function() &#123;      var f1 = () =&gt; &#123;        console.log(this.a);        console.log(this.id);      &#125;      f1();    &#125;,    say3: () =&gt; &#123;      var f1 = () =&gt; &#123;        console.log(this.a);        console.log(this.id);      &#125;      f1();    &#125;  &#125;  console.log(&#39;================================&#39;);  obj.say1.call(obj2) //window 1(箭头函数this指向不可被改变)  console.log(&#39;================================&#39;);  obj.say2.call(obj2)//obj2 2  console.log(&#39;================================&#39;);  obj.say3.call(obj2)//window 1  console.log(&#39;================================&#39;);  obj.say1()//window 1  console.log(&#39;================================&#39;);  obj.say2()//obj 3  console.log(&#39;================================&#39;);  obj.say3()//window 1  console.log(&#39;================================&#39;);</code></pre><hr><p>参考文档:<a href="https://blog.csdn.net/qq_36356218/article/details/80908021">CSDN文章:function(){} 和 () =&gt;{} 中this指向的问题</a>;</p><p>扩展阅读:<a href="https://blog.csdn.net/u012719257/article/details/46006671">CSDN文章:使用(function() {}).call(this);包裹代码有什么好处，什么时候应该这样做?</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-响应式原理</title>
      <link href="2021/02/23/%E5%89%8D%E7%AB%AF/vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>2021/02/23/%E5%89%8D%E7%AB%AF/vue/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue是基于 Object.defineProperty 来实现数据响应;</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"><a href="#根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。" class="headerlink" title="根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。"></a>根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。</h4><ol><li><p>对象内部通过defineReactive方法，使用 Object.defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；</p></li><li><p>数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法，通过监听这些方法可以做到依赖收集和派发更新；</p></li></ol><p>多层对象是通过递归来实现劫持，vue3中是使用 proxy来实现响应式数据</p><p>补充回答：</p><p>内部依赖收集是怎么做到的，每个属性都拥有自己的dep属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher去更新。</p><h4 id="响应式流程："><a href="#响应式流程：" class="headerlink" title="响应式流程："></a>响应式流程：</h4><p>1､defineReactive  把数据定义成响应式的；</p><p>2､给属性增加一个 dep，用来收集对应的那些watcher；</p><p>3､等数据变化进行更新</p><p>dep.depend() // get 取值：进行依赖收集</p><p>dep.notify() // set 设置时：通知视图更新</p><h4 id="性能优化相关的内容："><a href="#性能优化相关的内容：" class="headerlink" title="性能优化相关的内容："></a>性能优化相关的内容：</h4><p>1)对象层级过深，性能就会差。</p><p>2)不需要响应数据的内容不要放在data中。</p><p>3)object.freeze()  可以冻结数据。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h6><p>最近一段时间在阅读Vue源码，从它的核心原理入手，开始了源码的学习，而其核心原理就是其数据的响应式，讲到Vue的响应式原理，我们可以从它的兼容性说起，Vue不支持IE8以下版本的浏览器，因为Vue是基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 来实现数据响应的，而        Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 <strong>getter/setter</strong> 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据；</p><p>受现代JavaScript 的限制 (以及废弃 <strong>Object.observe</strong>)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <strong>getter/setter</strong> 转化过程，所以属性必须在 <strong>data</strong> 对象上存在才能让Vue转换它，这样才能让它是响应的。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617554b425a3431?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="vue响应式"></p><p>我们这里是根据Vue2.3源码进行分析,Vue数据响应式变化主要涉及 <strong>Observer</strong>, <strong>Watcher</strong> , <strong>Dep</strong> 这三个主要的类；因此要弄清Vue响应式变化需要明白这个三个类之间是如何运作联系的；以及它们的原理，负责的逻辑操作。那么我们从一个简单的Vue实例的代码来分析Vue的响应式原理</p><pre><code class="javascript">var vue = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        name: &#39;Junga&#39;    &#125;,    created () &#123;        this.helloWorld()    &#125;,    methods: &#123;        helloWorld: function() &#123;            console.log(&#39;my name is&#39; + this.name)        &#125;    &#125;    ...&#125;)</code></pre><h5 id="Vue初始化实例"><a href="#Vue初始化实例" class="headerlink" title="Vue初始化实例"></a>Vue初始化实例</h5><p>根据Vue的<a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期</a>我们知道，Vue首先会进行init初始化操作；源码在<a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/instance/init.js">src/core/instance/init.js</a>中</p><pre><code class="javascript">/*初始化生命周期*/initLifecycle(vm)/*初始化事件*/initEvents(vm)Object.defineProperty /*初始化render*/initRender(vm)/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/callHook(vm, &#39;beforeCreate&#39;)initInjections(vm) // resolve injections before data/props/*初始化props、methods、data、computed与watch*/initState(vm)initProvide(vm) // resolve provide after data/props/*调用created钩子函数并且触发created钩子事件*/callHook(vm, &#39;created&#39;)</code></pre><p>以上代码可以看到 <strong>initState(vm)</strong> 是用来初始化props,methods,data,computed和watch;</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/instance/state.js">src/core/instance/state.js</a></p><pre><code class="javascript">/*初始化props、methods、data、computed与watch*/export function initState (vm: Component) &#123;  vm._watchers = []  const opts = vm.$options  /*初始化props*/  if (opts.props) initProps(vm, opts.props)  /*初始化方法*/  if (opts.methods) initMethods(vm, opts.methods)  /*初始化data*/  if (opts.data) &#123;    initData(vm)  &#125; else &#123;    /*该组件没有data的时候绑定一个空对象*/    observe(vm._data = &#123;&#125;, true /* asRootData */)  &#125;  /*初始化computed*/  if (opts.computed) initComputed(vm, opts.computed)  /*初始化watchers*/  if (opts.watch) initWatch(vm, opts.watch)&#125;.../*初始化data*/function initData (vm: Component) &#123;  /*得到data数据*/  let data = vm.$options.data  data = vm._data = typeof data === &#39;function&#39;    ? getData(data, vm)    : data || &#123;&#125;defi  ...  //遍历data中的数据  while (i--) &#123;    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(        `The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(keys[i])) &#123;      /*判断是否是保留字段*/      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/      proxy(vm, `_data`, keys[i])    &#125;  &#125;  // observe data  /*这里通过observe实例化Observe对象，开始对数据进行绑定，asRootData用来根数据，用来计算实例化根数据的个数，下面会进行递归observe进行对深层对象的绑定。则asRootData为非true*/  observe(data, true /* asRootData */)&#125;</code></pre><h6 id="1、initData"><a href="#1、initData" class="headerlink" title="1、initData"></a>1、initData</h6><p>现在我们重点分析下<strong>initData</strong>，这里主要做了两件事，一是将_data上面的数据代理到vm上，二是通过执行 observe(data, true / <em>asRootData</em> /)将所有data变成可观察的，即对data定义的每个属性进行getter/setter操作，这里就是Vue实现响应式的基础；<strong>observe</strong>的实现如下 <a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/index.js">src/core/observer/index.js</a></p><pre><code class="javascript"> /*尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。*/export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value)) &#123;    return  &#125;  let ob: Observer | void  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例，这里可以看Observer实例化的代码def(value, &#39;__ob__&#39;, this)*/  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。而且该对象在shouldConvert的时候才会进行Observer。这是一个标识位，避免重复对value进行Observer    */    observerState.shouldConvert &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;     /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/    ob.vmCount++  &#125;  return ob&#125;</code></pre><p>这里 <strong>new Observer(value)</strong> 就是实现响应式的核心方法之一了，通过它将data转变可以成观察的，而这里正是我们开头说的，用了 <strong>Object.defineProperty</strong> 实现了data的 <strong>getter/setter</strong> 操作，通过 <strong>Watcher</strong> 来观察数据的变化，进而更新到视图中。</p><h6 id="2、Observer"><a href="#2、Observer" class="headerlink" title="2、Observer"></a>2、Observer</h6><p>Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/index.js">src/core/observer/index.js</a></p><pre><code class="javascript">export class Observer &#123;  value: any;  dep: Dep;  vmCount: number; // number of vms that has this object as root $data  constructor (value: any) &#123;    this.value = value    this.dep = new Dep()    this.vmCount = 0    /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考/src/core/util/lang.js*/    def(value, &#39;__ob__&#39;, this)    if (Array.isArray(value)) &#123;      /*如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。*/      const augment = hasProto        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/      augment(value, arrayMethods, arrayKeys)      /*如果是数组则需要遍历数组的每一个成员进行observe*/      this.observeArray(value)    &#125; else &#123;      /*如果是对象则直接walk进行绑定*/      this.walk(value)    &#125;,    walk (obj: Object) &#123;      const keys = Object.keys(obj)      /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/      for (let i = 0; i &lt; keys.length; i++) &#123;        defineReactive(obj, keys[i], obj[keys[i]])      &#125;    &#125;  &#125;</code></pre><ol><li>首先将Observer实例绑定到data的<strong>ob</strong>属性上面去，防止重复绑定；</li><li>若data为数组，先实现对应的<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">变异方法</a>（这里变异方法是指Vue重写了数组的7种原生方法，这里不做赘述，后续再说明），再将数组的每个成员进行observe，使之成响应式数据；</li><li>否则执行walk()方法，遍历data所有的数据，进行getter/setter绑定，这里的核心方法就是 <strong>defineReative(obj, keys[i], obj[keys[i]])</strong></li></ol><pre><code>export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: Function) &#123;  /*在闭包中定义一个dep对象*/  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;    return  &#125;  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/  // cater for pre-defined getter/setters  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  /*对象的子对象递归进行observe并返回子节点的Observer对象*/  let childOb = observe(val)  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      /*如果原本对象拥有getter方法则执行*/      const value = getter ? getter.call(obj) : val      if (Dep.target) &#123;        /*进行依赖收集*/        dep.depend()        if (childOb) &#123;          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/          childOb.dep.depend()        &#125;        if (Array.isArray(value)) &#123;          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/          dependArray(value)        &#125;      &#125;      return value    &#125;,    set: function reactiveSetter (newVal) &#123;      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        return      &#125;      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) &#123;        customSetter()      &#125;      if (setter) &#123;        /*如果原本对象拥有setter方法则执行setter*/        setter.call(obj, newVal)      &#125; else &#123;        val = newVal      &#125;      /*新的值需要重新进行observe，保证数据响应式*/      childOb = observe(newVal)      /*dep对象通知所有的观察者*/      dep.notify()    &#125;  &#125;)&#125;复制代码</code></pre><p>其中getter方法：</p><ol><li>先为每个data声明一个 <strong>Dep</strong> 实例对象，被用于getter时执行dep.depend()进行收集相关的依赖;</li><li>根据Dep.target来判断是否收集依赖，还是普通取值。Dep.target是在什么时候，如何收集的后面再说明，先简单了解它的作用，</li></ol><p>那么问题来了，我们为啥要收集相关依赖呢？</p><pre><code class="javascript">new Vue(&#123;    template:         `&lt;div&gt;            &lt;span&gt;text1:&lt;/span&gt; &#123;&#123;text1&#125;&#125;            &lt;span&gt;text2:&lt;/span&gt; &#123;&#123;text2&#125;&#125;        &lt;div&gt;`,    data: &#123;        text1: &#39;text1&#39;,        text2: &#39;text2&#39;,        text3: &#39;text3&#39;    &#125;&#125;);</code></pre><p>我们可以从以上代码看出，data中text3并没有被模板实际用到，为了提高代码执行效率，我们没有必要对其进行响应式处理，因此，依赖收集简单点理解就是收集只在实际页面中用到的data数据，然后打上标记，这里就是标记为Dep.target。</p><p>在setter方法中:</p><ol><li>获取新的值并且进行observe，保证数据响应式；</li><li>通过dep对象通知所有观察者去更新数据，从而达到响应式效果。</li></ol><p>在Observer类中，我们可以看到在getter时，dep会收集相关依赖，即收集依赖的watcher，然后在setter操作时候通过dep去通知watcher,此时watcher就执行变化，我们用一张图描述这三者之间的关系：<br><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617554b5e866e59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="关系图"></p><p>从图我们可以简单理解：Dep可以看做是书店，Watcher就是书店订阅者，而Observer就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。</p><h6 id="3、Watcher"><a href="#3、Watcher" class="headerlink" title="3、Watcher"></a>3、Watcher</h6><p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/watcher.js">src/core/observer/watcher.js</a></p><pre><code class="javascript">export default class Watcher &#123;  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: Object  ) &#123;    this.vm = vm    /*_watchers存放订阅者实例*/    vm._watchers.push(this)    // options    if (options) &#123;      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync    &#125; else &#123;      this.deep = this.user = this.lazy = this.sync = false    &#125;    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== &#39;production&#39;      ? expOrFn.toString()      : &#39;&#39;    // parse expression for getter    /*把表达式expOrFn解析成getter*/    if (typeof expOrFn === &#39;function&#39;) &#123;      this.getter = expOrFn    &#125; else &#123;      this.getter = parsePath(expOrFn)      if (!this.getter) &#123;        this.getter = function () &#123;&#125;        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +          &#39;Watcher only accepts simple dot-delimited paths. &#39; +          &#39;For full control, use a function instead.&#39;,          vm        )      &#125;    &#125;    this.value = this.lazy      ? undefined      : this.get()  &#125;  /**   * Evaluate the getter, and re-collect dependencies.   */   /*获得getter的值并且重新进行依赖收集*/  get () &#123;    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/    pushTarget(this)    let value    const vm = this.vm    /*执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。      在将Dep.target设置为自生观察者实例以后，执行getter操作。      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，      那么在执行getter的时候就会触发a跟c两个数据的getter函数，      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，      将该观察者对象放入闭包中的Dep的subs中去。*/    if (this.user) &#123;      try &#123;        value = this.getter.call(vm, vm)      &#125; catch (e) &#123;        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)      &#125;    &#125; else &#123;      value = this.getter.call(vm, vm)    &#125;    // &quot;touch&quot; every property so they are all tracked as    // dependencies for deep watching    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/    if (this.deep) &#123;      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/      traverse(value)    &#125;    /*将观察者实例从target栈中取出并设置给Dep.target*/    popTarget()    this.cleanupDeps()    return value  &#125;  /**   * Add a dependency to this directive.   */   /*添加一个依赖关系到Deps集合中*/  addDep (dep: Dep) &#123;    const id = dep.id    if (!this.newDepIds.has(id)) &#123;      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) &#123;        dep.addSub(this)      &#125;    &#125;  &#125;  /**   * Clean up for dependency collection.   */   /*清理依赖收集*/  cleanupDeps () &#123;    /*移除所有观察者对象*/    ...  &#125;  /**   * Subscriber interface.   * Will be called when a dependency changes.   */   /*      调度者接口，当依赖发生改变的时候进行回调。   */  update () &#123;    /* istanbul ignore else */    if (this.lazy) &#123;      this.dirty = true    &#125; else if (this.sync) &#123;      /*同步则执行run直接渲染视图*/      this.run()    &#125; else &#123;      /*异步推送到观察者队列中，下一个tick时调用。*/      queueWatcher(this)    &#125;  &#125;  /**   * Scheduler job interface.   * Will be called by the scheduler.   */   /*      调度者工作接口，将被调度者回调。    */  run () &#123;    if (this.active) &#123;      /* get操作在获取value本身也会执行getter从而调用update更新视图 */      const value = this.get()      if (        value !== this.value ||        // Deep watchers and watchers on Object/Arrays should fire even        // when the value is the same, because the value may        // have mutated.        /*            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。        */        isObject(value) ||        this.deep      ) &#123;        // set new value        const oldValue = this.value        /*设置新的值*/        this.value = value        /*触发回调*/        if (this.user) &#123;          try &#123;            this.cb.call(this.vm, value, oldValue)          &#125; catch (e) &#123;            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)          &#125;        &#125; else &#123;          this.cb.call(this.vm, value, oldValue)        &#125;      &#125;    &#125;  &#125;  /**   * Evaluate the value of the watcher.   * This only gets called for lazy watchers.   */   /*获取观察者的值*/  evaluate () &#123;    this.value = this.get()    this.dirty = false  &#125;  /**   * Depend on all deps collected by this watcher.   */   /*收集该watcher的所有deps依赖*/  depend () &#123;    let i = this.deps.length    while (i--) &#123;      this.deps[i].depend()    &#125;  &#125;  /**   * Remove self from all dependencies&#39; subscriber list.   */   /*将自身从所有依赖收集订阅列表删除*/  teardown () &#123;   ...  &#125;&#125;</code></pre><h6 id="4、Dep"><a href="#4、Dep" class="headerlink" title="4、Dep"></a>4、Dep</h6><p>被Observer的data在触发 <strong>getter</strong> 时，<strong>Dep</strong> 就会收集依赖的 <strong>Watcher</strong> ，其实 <strong>Dep</strong> 就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过 <strong>Dep</strong> 给 <strong>Watcher</strong> 发通知进行更新。</p><p><a href="https://github.com/tangyuxian/Vue-learn/blob/master/core/observer/dep.js">src/core/observer/dep.js</a></p><pre><code class="javascript">export default class Dep &#123;  static target: ?Watcher;  id: number;  subs: Array&lt;Watcher&gt;;  constructor () &#123;    this.id = uid++    this.subs = []  &#125;  /*添加一个观察者对象*/  addSub (sub: Watcher) &#123;    this.subs.push(sub)  &#125;  /*移除一个观察者对象*/  removeSub (sub: Watcher) &#123;    remove(this.subs, sub)  &#125;  /*依赖收集，当存在Dep.target的时候添加观察者对象*/  depend () &#123;    if (Dep.target) &#123;      Dep.target.addDep(this)    &#125;  &#125;  /*通知所有订阅者*/  notify () &#123;    // stabilize the subscriber list first    const subs = this.subs.slice()    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实在 <strong>Vue</strong> 中初始化渲染时，视图上绑定的数据就会实例化一个 <strong>Watcher</strong>，依赖收集就是是通过属性的 <strong>getter</strong> 函数完成的，文章一开始讲到的 <strong>Observer</strong> 、<strong>Watcher</strong> 、<strong>Dep</strong> 都与依赖收集相关。其中 <strong>Observer</strong> 与 <strong>Dep</strong>        是一对一的关系， <strong>Dep</strong> 与 <strong>Watcher</strong> 是多对多的关系，<strong>Dep</strong> 则是 <strong>Observer</strong> 和 <strong>Watcher</strong> 之间的纽带。依赖收集完成后，当属性变化会执行被 <strong>Observer</strong> 对象的 <strong>dep.notify()</strong> 方法，这个方法会遍历订阅者（Watcher）列表向其发送消息，        <strong>Watcher</strong> 会执行 <strong>run</strong> 方法去更新视图，我们再来看一张图总结一下：<br><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617554b4aa4d4c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="关系图"></p><ol><li><p>在 <strong>Vue</strong> 中模板编译过程中的指令或者数据绑定都会实例化一个 <strong>Watcher</strong> 实例，实例化过程中会触发 <strong>get()</strong> 将自身指向 <strong>Dep.target</strong>;</p></li><li><p>data在 <strong>Observer</strong> 时执行 <strong>getter</strong> 会触发 <strong>dep.depend()</strong> 进行依赖收集;依赖收集的结果：</p><p>  1.data在 <strong>Observer</strong> 时闭包的dep实例的subs添加观察它的 <strong>Watcher</strong> 实例；</p><p>  2.Watcher** 的deps中添加观察对象 <strong>Observer</strong> 时的闭包dep；</p></li><li><p>当data中被 <strong>Observer</strong> 的某个对象值变化后，触发subs中观察它的watcher执行 <strong>update()</strong> 方法，最后实际上是调用watcher的回调函数cb，进而更新视图。</p></li></ol><hr><p>参考文档:<a href="https://juejin.cn/post/6844903561327820808">掘金文章:理解vue相应原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-Vue.use()原理及使用</title>
      <link href="2021/02/22/%E5%89%8D%E7%AB%AF/vue/vue-Vue.use()%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/22/%E5%89%8D%E7%AB%AF/vue/vue-Vue.use()%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="主要执行流程"><a href="#主要执行流程" class="headerlink" title="主要执行流程"></a>主要执行流程</h4><p>1､检查插件是否注册，若已注册，则直接跳出；</p><p>2､处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；</p><p>3､执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>插件不能重复的加载:install 方法的第一个参数是vue的构造函数，其他参数是Vue.set中除了第一个参数的其他参数； 代码：args.unshift(this)</p></li><li><p>调用插件的install 方法 代码：typeof plugin.install === ‘function’</p></li><li><p>插件本身是一个函数，直接让函数执行。 代码：plugin.apply(null, args)</p></li><li><p>缓存插件。 代码：installedPlugins.push(plugin)</p></li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js">https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="1举例分析"><a href="#1举例分析" class="headerlink" title="1举例分析"></a>1举例分析</h6><p>创建两个文件</p><pre><code class="javascript">// plugins.jsconst Plugin1 = &#123;  install(a,b)&#123;    console.log(&#39;Plugin1 第一个参数：&#39;,a)    console.log(&#39;Plugin1 第二个参数：&#39;,b)  &#125;&#125;function Plugin2(a,b)&#123;  console.log(&#39;Plugin2 第一个参数：&#39;,a)  console.log(&#39;Plugin2 第二个参数：&#39;,b)&#125;export&#123;Plugin1,Plugin2&#125;</code></pre><pre><code class="javascript">// use.js import Vue from &#39;vue&#39;import &#123;Plugin1,Plugin2&#125; from &#39;./plugins&#39;Vue.use(Plugin1,&#39;参数1&#39;)Vue.use(Plugin2,&#39;参数A&#39;)</code></pre><pre><code class="javascript">// main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;import &#39;./assets/plugins/use&#39;Vue.config.productionTip = falsenew Vue(&#123;  router,  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><p>从中可以发现我们在 plugin1 中的 install 方法编写的两个 console 都打印出来，第一个打印出来的是Vue对象，第二个是我们传入的参数。<br>而 plugin2 没有 install 方法，它本身就是一个方法，也能打印两个参数，第一个是Vue对象，第二个是我们传入的参数。<br>那么现在我们是不是大概对Vue.use有一个模糊的猜想.</p><h6 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h6><p><strong>toArray 源码</strong></p><pre><code class="javascript">export function toArray (list: any, start?: number): Array&lt;any&gt; &#123;  start = start || 0  let i = list.length - start  const ret: Array&lt;any&gt; = new Array(i)  while (i--) &#123;    ret[i] = list[i + start]  &#125;  return ret&#125;</code></pre><p><strong>use源码</strong></p><pre><code class="javascript">import &#123; toArray &#125; from &#39;../util/index&#39;export function initUse (Vue: GlobalAPI) &#123;  Vue.use = function (plugin: Function | Object) &#123;    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;      return this    &#125;    // additional parameters    const args = toArray(arguments, 1)    args.unshift(this)    if (typeof plugin.install === &#39;function&#39;) &#123;      plugin.install.apply(plugin, args)    &#125; else if (typeof plugin === &#39;function&#39;) &#123;      plugin.apply(null, args)    &#125;    installedPlugins.push(plugin)    return this  &#125;&#125;</code></pre><p>从源码中我们可以发现 vue 首先判断这个插件是否被注册过，不允许重复注册，并且接收的 plugin 参数的限制是 Function | Object 两种类型。<br>对于这两种类型有不同的处理。<br>首先将我们传入的参数整理成数组： const args = toArray(arguments, 1)；<br>再将 Vue 对象添加到这个数组的起始位置 args.unshift(this) ,这里的 this 指向 Vue 对象；<br>如果我们传入的 plugin(Vue.use的第一个参数) 的 install 是一个方法。也就是说如果我们传入一个对象，对象中包含 install 方法，那么我们就调用这个 plugin 的 install 方法并将整理好的数组当成参数传入 install 方法中， plugin.install.apply(plugin, args)；<br>如果我们传入的 plugin 就是一个函数,那么我们就直接调用这个函数并将整理好的数组当成参数传入， plugin.apply(null, args)；<br>之后给这个插件添加至已经添加过的插件数组中，标示已经注册过 installedPlugins.push(plugin)；<br>最后返回 Vue 对象。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>通过以上分析我们可以知道，在我们以后编写插件的时候可以有两种方式。<br>一种是将这个插件的逻辑封装成一个对象，最后将在 install 编写业务代码暴露给 Vue 对象。这样做的好处是可以添加任意参数在这个对象上方便将 install 函数封装得更加精简，可拓展性也比较高。<br>还有一种则是将所有逻辑都编写成一个函数暴露给 Vue。<br>其实两种方法原理都一样，无非第二种就是将这个插件直接当成 install 函数来处理。<br>个人觉得第一种方式比较合理。</p><hr><p>参考文档:<a href="https://blog.csdn.net/ZYS10000/article/details/107246076/">csdn上的文章:Vue中 Vue.use() 原理及使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-new Vue()中发生了什么?</title>
      <link href="2021/02/22/%E5%89%8D%E7%AB%AF/vue/Vue-new%20Vue()%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>2021/02/22/%E5%89%8D%E7%AB%AF/vue/Vue-new%20Vue()%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>new Vue()是实例化一个Vue对象,在构造函数中执行_init(options)，随后导入五大Mixin,进行实例化的初始化过程</p><span id="more"></span><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h4 id="五大Mixin-进行实例化的初始化过程如下"><a href="#五大Mixin-进行实例化的初始化过程如下" class="headerlink" title="五大Mixin,进行实例化的初始化过程如下"></a>五大Mixin,进行实例化的初始化过程如下</h4><ol><li>initMixin(Vue)  <em>// options初始化</em></li><li>stateMixin(Vue) <em>// 状态（props、state、computed、watch）</em></li><li>eventsMixin(Vue) <em>// 事件</em></li><li>lifecycleMixin(Vue) <em>// 生命周期</em></li><li>renderMixin(Vue) <em>// 页面渲染</em></li></ol><h4 id="含义简介"><a href="#含义简介" class="headerlink" title="含义简介"></a>含义简介</h4><p>initLifecycle:初始化生命周期</p><p>initEvents：初始化事件</p><p>initRender：渲染页面</p><p>callHook(vm,’beforeCreate’) ：beforeCreate钩子函数</p><p>initState：初始化状态 props data computed watch methods</p><p>callHook(vm,’created’):created钩子函数</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js">https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h6 id="1-vue入口：new-Vue-构造函数"><a href="#1-vue入口：new-Vue-构造函数" class="headerlink" title="1. vue入口：new Vue()构造函数"></a>1. vue入口：new Vue()构造函数</h6><pre><code class="jsx">// vue/src/platform/web/entry-runtime.js/* @flow  */import Vue from &#39;./runtime/index&#39;export default Vue</code></pre><p>从vue1到vue2的迭代上，vue采用了flow进行静态代码类型检查</p><pre><code class="jsx"> // vue/src/platform/web/runtime/index.jsimport Vue from &#39;core/index&#39;import config from &#39;core/config&#39;import &#123; extend, noop &#125; from &#39;shared/util&#39;import &#123; mountComponent &#125; from &#39;core/instance/lifecycle&#39;import &#123; devtools, inBrowser, isChrome &#125; from &#39;core/util/index&#39;</code></pre><p>继续找到Vue的引用所在地</p><pre><code class="jsx">// vue/src/core/instance/index.jsimport &#123; initMixin &#125; from &#39;./init&#39;import &#123; stateMixin &#125; from &#39;./state&#39;import &#123; renderMixin &#125; from &#39;./render&#39;import &#123; eventsMixin &#125; from &#39;./events&#39;import &#123; lifecycleMixin &#125; from &#39;./lifecycle&#39;import &#123; warn &#125; from &#39;../util/index&#39;function Vue (options) &#123;  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;    !(this instanceof Vue)  ) &#123;    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)  &#125;  this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue</code></pre><h6 id="2-构造函数干了什么"><a href="#2-构造函数干了什么" class="headerlink" title="2. 构造函数干了什么"></a>2. 构造函数干了什么</h6><p>到这里，我们可以在上述代码中看到Vue的构造函数，在构造函数中执行了<code>_init</code>，随后执行了导入的五大Mixin，进行实例化的初始化过程</p><pre><code class="cpp">initMixin(Vue)  // options初始化stateMixin(Vue) // 状态（props、state、computed、watch）eventsMixin(Vue) // 事件lifecycleMixin(Vue) // 生命周期renderMixin(Vue) // 页面渲染</code></pre><p>找到<code>_init</code>执行函数</p><pre><code class="jsx">export function initMixin (Vue: Class&lt;Component&gt;) &#123;  Vue.prototype._init = function (options?: Object) &#123;    const vm: Component = this    // a uid    vm._uid = uid++    ...</code></pre><p>这个函数主要对我们在实例化中的配置与默认配置进行了合并，并且依次执行了以下几步</p><pre><code class="javascript">initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, &#39;beforeCreate&#39;)initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, &#39;created&#39;)/* istanbul ignore if */if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;  vm._name = formatComponentName(vm, false)  mark(endTag)  measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)&#125;if (vm.$options.el) &#123;  vm.$mount(vm.$options.el)&#125;</code></pre><p>initLifecycle： 初始化生命周期<br> initEvents： 初始化事件<br> initRender： 渲染页面<br> callHook(vm, ‘beforeCreate’)： beforeCreate钩子函数<br> initState：初始化状态  props data computed  watch methods<br> callHook(vm, ‘created’)：created钩子函数</p><p>我们重点关注下 initState中的 initData，也就是老生常谈的数据双向绑定</p><pre><code class="javascript">function initData (vm: Component) &#123;let data = vm.$options.datadata = vm._data = typeof data === &#39;function&#39;  ? getData(data, vm)  : data || &#123;&#125;if (!isPlainObject(data)) &#123;  data = &#123;&#125;  process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(    &#39;data functions should return an object:\n&#39; +    &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,    vm  )&#125;// proxy data on instanceconst keys = Object.keys(data)const props = vm.$options.propsconst methods = vm.$options.methodslet i = keys.lengthwhile (i--) &#123;  const key = keys[i]  if (process.env.NODE_ENV !== &#39;production&#39;) &#123;    if (methods &amp;&amp; hasOwn(methods, key)) &#123;      warn(        `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,        vm      )    &#125;  &#125;  if (props &amp;&amp; hasOwn(props, key)) &#123;    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(      `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +      `Use prop default value instead.`,      vm    )  &#125; else if (!isReserved(key)) &#123;    proxy(vm, `_data`, key)  &#125;&#125;  // observe data  observe(data, true /* asRootData */)&#125;</code></pre><p>在上面的代码中找到两个关键字 <code>proxy</code> 和 <code>observe</code><br> 前者的作用：<br> 我们在vue中调用数据： this.demo = 123<br> 但是在源码初始化的过程中，是这样的 this._data.demo = 123<br> proxy就是将key值做了代理，简化了调用，方便了我们</p><p>后者的作用：<br> 开始进行双向数据绑定  observe(data, true /* asRootData */)</p><p>简化后的observe</p><pre><code class="javascript">export function observe (value) &#123;    if (!isObject(value)) &#123;        return    &#125;    let ob = new Observer(value)    return ob&#125;export class Observer &#123;    constructor (value) &#123;        this.value = value        this.dep = new Dep()        this.vmCount = 0        def(value, &#39;__ob__&#39;, this)        this.walk(value)    &#125;    walk (obj) &#123;        const keys = Object.keys(obj)        for (let i = 0; i &lt; keys.length; i++) &#123;            defineReactive(obj, keys[i], obj[keys[i]])        &#125;    &#125;&#125;export function defineReactive (obj, key, val) &#123;    const dep = new Dep()    let childOb = observe(val)    Object.defineProperty(obj, key, &#123;        enumerable: true,        configurable: true,        // 取值时给数据添加依赖        get: function reactiveGetter () &#123;            const value = val            if (Dep.target) &#123;                dep.depend()                if (childOb) &#123;                    childOb.dep.depend()                &#125;            &#125;            return value        &#125;,        // 赋值时通知数据依赖更新        set: function reactiveSetter (newVal) &#123;            const value = val            if (newVal === value) &#123;                return            &#125;            val = newVal            childOb = observe(newVal)            dep.notify()        &#125;    &#125;)&#125;</code></pre><p>这里在简单阐述下vue双向数据绑定的原理：</p><p>发布者-订阅者 + 数据劫持</p><p>在上述的代码中，重点关注 <code>defineReactive</code>函数，对vue对象中的每个属性进行了递归遍历的监听，利用 <code>Object.defineProperty</code>对每个属性进行监听，在取值的时候添加依赖进行依赖收集，在复制的时候进行通知订阅者进行依赖更新。</p><hr><p>参考文档:<a href="https://www.jianshu.com/p/5ca5f40e4810">简书上的文章:new Vue大致干了啥</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-基于vue的SEO方案</title>
      <link href="2021/02/20/%E5%89%8D%E7%AB%AF/vue/vue-%E5%9F%BA%E4%BA%8Evue%E7%9A%84SEO%E6%96%B9%E6%A1%88/"/>
      <url>2021/02/20/%E5%89%8D%E7%AB%AF/vue/vue-%E5%9F%BA%E4%BA%8Evue%E7%9A%84SEO%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因vue是spa单页面应用,对seo不友好,所以针对该问题整合了目前网上提到的解决方案以供参考</p><span id="more"></span><h2 id="了解SEO"><a href="#了解SEO" class="headerlink" title="了解SEO"></a>了解SEO</h2><p>搜索引擎优化（Search engine optimization，简称seo），指为了提升网页在搜索引擎自然搜索结果中（非商业性推广结果）的收录数量以及排序位置而做的优化行为，是为了从搜索引擎中获得更多的免费流量，以及更好的展现形象。</p><h2 id="seo对vue单页面不友好的原因"><a href="#seo对vue单页面不友好的原因" class="headerlink" title="seo对vue单页面不友好的原因"></a>seo对vue单页面不友好的原因</h2><ul><li>爬虫在爬取的过程中，不会去执行js，所以隐藏在js中的跳转也不会获取到</li><li>vue通过js控制路由然后渲染出对应的页面，而搜索引擎蜘蛛是不会去执行页面的js的，导致搜索引擎蜘蛛只能收录index.html一个页面，在百度中就搜索不到相关的子页面的内容。</li><li>我们加载页面的时候,浏览器的渲染包含:html的解析、dom树的构建、cssom构建、javascript解析、布局、绘制,当解析到javascript的时候才回去触发vue的渲染,然后元素挂载到id为app的div上,这个时候我们才能看到我们页面的内容,所以即使vue渲染机制很快我们仍然能够看到一段时间的白屏情况,用户体验不好</li></ul><h2 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h2><ul><li>1.SSR服务器渲染；</li><li>2.静态化；</li><li>3.预渲染prerender-spa-plugin；</li><li>4.使用Phantomjs针对爬虫做处理。</li></ul><h4 id="1-SSR服务器渲染"><a href="#1-SSR服务器渲染" class="headerlink" title="1.SSR服务器渲染"></a>1.SSR服务器渲染</h4><p>关于服务器渲染：Vue官网介绍，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p><p>使用SSR权衡之处：</p><ul><li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li><li>环境和部署要求更高，需要Node.js server 运行环境；</li><li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><h6 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h6><ul><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li><li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li></ul><h6 id="不足：（开发中遇到的坑）"><a href="#不足：（开发中遇到的坑）" class="headerlink" title="不足：（开发中遇到的坑）"></a>不足：（开发中遇到的坑）</h6><p>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：</p><pre><code class="javascript">if(process.browser)&#123; console.log(window);&#125;</code></pre><p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：</p><pre><code class="javascript">if (process.browser) &#123;     var &#123; WOW &#125; = require(&#39;wowjs&#39;);     require(&#39;wowjs/css/libs/animate.css&#39;); &#125;</code></pre><p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于页面组件调用：</p><pre><code class="javascript">// 并发加载多个接口：  async asyncData (&#123; app, query &#125;) &#123;    let [resA, resB, resC] = await Promise.all([      app.$axios.get(&#39;/api/a&#39;),      app.$axios.get(&#39;/api/b&#39;),      app.$axios.get(&#39;/api/c&#39;),     ])          return &#123;       dataA: resA.data,       dataB: resB.data,       dataC: resC.data,     &#125;  &#125;</code></pre><p>在asyncData中获取参数：</p><pre><code class="javascript">1.获取动态路由参数，如：/list/:id&#39; ==&gt;  &#39;/list/123接收：async asyncData (&#123; app, query &#125;) &#123;  console.log(app.context.params.id) //123&#125;2.获取url?获取参数，如：/list?id=123接收：async asyncData (&#123; app, query &#125;) &#123;  console.log(query.id) //123&#125;</code></pre><p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：</p><pre><code class="javascript">Error while initializing app DOMException: Failed to execute &#39;appendChild&#39; on &#39;Node&#39;: This node type does not support this method.    at Object.We [as appendChild]</code></pre><p>根据github nuxt上的issue第1552条提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p><h4 id="2-静态化"><a href="#2-静态化" class="headerlink" title="2.静态化"></a>2.静态化</h4><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。 在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。</p><pre><code class="javascript">-| pages/---| index.vue---| users/-----| _id.vue</code></pre><p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。</p><pre><code class="javascript">// nuxt.config.jsmodule.exports = &#123;  generate: &#123;    routes: [      &#39;/users/1&#39;,      &#39;/users/2&#39;,      &#39;/users/3&#39;    ]  &#125;&#125;</code></pre><p>运行打包，即可看见打包出来的页面。 但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p><ul><li>使用一个返回 Promise 对象类型 的 函数；</li><li>使用一个回调是 callback(err, params) 的 函数。</li></ul><pre><code class="javascript">// nuxt.config.jsimport axios from &#39;axios&#39;export default &#123;  generate: &#123;    routes: function () &#123;      return axios.get(&#39;https://my-api/users&#39;)      .then((res) =&gt; &#123;        return res.data.map((user) =&gt; &#123;          return &#123;            route: &#39;/users/&#39; + user.id,            payload: user          &#125;        &#125;)      &#125;)    &#125;  &#125;&#125;</code></pre><p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：</p><pre><code class="javascript">async asyncData (&#123; params, error, payload &#125;) &#123;  if (payload) return &#123; user: payload &#125;  else return &#123; user: await backend.fetchUser(params.id) &#125;&#125;</code></pre><p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。 优势：</p><ul><li>纯静态文件，访问速度超快；</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><p>不足：</p><ul><li>如果动态路由参数多的话不适用。</li></ul><h4 id="3-预渲染prerender-spa-plugin"><a href="#3-预渲染prerender-spa-plugin" class="headerlink" title="3.预渲染prerender-spa-plugin"></a>3.预渲染prerender-spa-plugin</h4><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p><pre><code class="javascript">$ cnpm install prerender-spa-plugin --save</code></pre><p>vue cli 3 <code>vue.config.js</code>配置：</p><pre><code class="javascript">const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;const path = require(&#39;path&#39;);module.exports = &#123;    configureWebpack: config =&gt; &#123;        if (process.env.NODE_ENV !== &#39;production&#39;) return;        return &#123;            plugins: [                new PrerenderSPAPlugin(&#123;                    // 生成文件的路径，也可以与webpakc打包的一致。                    // 下面这句话非常重要！！！                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。                    staticDir: path.join(__dirname,&#39;dist&#39;),                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。                    routes: [&#39;/&#39;, &#39;/product&#39;,&#39;/about&#39;],                    // 这个很重要，如果没有配置这段，也不会进行预编译                    renderer: new Renderer(&#123;                        inject: &#123;                            foo: &#39;bar&#39;                        &#125;,                        headless: false,                        // 在 main.js 中 document.dispatchEvent(new Event(&#39;render-event&#39;))，两者的事件名称要对应上。                        renderAfterDocumentEvent: &#39;render-event&#39;                    &#125;)                &#125;),            ],        &#125;;    &#125;&#125;</code></pre><p>在main.js中添加：</p><pre><code class="javascript">new Vue(&#123;  router,  render: h =&gt; h(App),  mounted () &#123;    document.dispatchEvent(new Event(&#39;render-event&#39;))  &#125;&#125;).$mount(&#39;#app&#39;)</code></pre><p>注意：router中必须设置 <code>mode: “history”</code>。</p><p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p><p>优势：</p><ul><li>改动小，引入个插件就完事；</li></ul><p>不足：</p><ul><li>无法使用动态路由；</li><li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li></ul><h4 id="4-使用Phantomjs针对爬虫做处理"><a href="#4-使用Phantomjs针对爬虫做处理" class="headerlink" title="4.使用Phantomjs针对爬虫做处理"></a>4.使用Phantomjs针对爬虫做处理</h4><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。 虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。 这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</p><img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/post/phantomjs.png" style="zoom: 50%;" /><p>具体代码戳这里：<a href="https://github.com/lengziyu/vue-seo-phantomjs">vue-seo-phantomjs</a>。 要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：</p><pre><code class="javascript">$ phantomjs spider.js &#39;https://www.baidu.com&#39;</code></pre><p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。 启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p><p>部署上线 线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p><pre><code class="javascript">upstream spider_server &#123;  server localhost:3000;&#125;server &#123;    listen       80;    server_name  example.com;        location / &#123;      proxy_set_header  Host            $host:$proxy_port;      proxy_set_header  X-Real-IP       $remote_addr;      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;        proxy_pass  http://spider_server;      &#125;    &#125;&#125;</code></pre><p>优势：</p><ul><li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li><li>对已用SPA开发完成的项目，这是不二之选。</li></ul><p>不足：</p><ul><li>部署需要node服务器支持；</li><li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li><li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li></ul><hr><p>引用来源点击<a href="https://cloud.tencent.com/developer/article/1674392">这里</a>,原作者的内容比较详细,里面多补充一些其它必要知识</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-常用原生功能封装</title>
      <link href="2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85/"/>
      <url>2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对微信小程序自身特性的功能进行封装使用</p><span id="more"></span><pre><code class="javascript">/** * 查询授权 * @param &#123;*&#125; scope  */const wxGetSetting = (scope) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.getSetting(&#123;      success(res) &#123;        if (!res.authSetting[&#39;scope.&#39; + scope]) &#123;          wx.authorize(&#123;            scope: &#39;scope.&#39; + scope,            success(res) &#123;              resolve(res)            &#125;,            fail(err) &#123;              wx.showToast(&#123;                title: &#39;请您到设置页面允许授权&#39;,                icon: &#39;none&#39;              &#125;)              wx.openSetting()              reject(err)            &#125;          &#125;)        &#125; else &#123;          resolve(&#123;&#125;)        &#125;      &#125;,      fail(err) &#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;/** * 微信登录功能 */const wxLogin = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.login(&#123;      success: function (res) &#123;        resolve(res)      &#125;    &#125;)  &#125;)&#125;/** * 获取个人信息 */const wxGetUserInfo = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wxGetSetting(&#39;userInfo&#39;).then(res =&gt; &#123;      wx.getUserInfo(&#123;        success: function (res) &#123;          resolve(res)        &#125;      &#125;)    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;/** * 保存图片 * @param &#123;*&#125; filePath  */const wxSaveImageToPhotosAlbum = (src,from=&quot;web&quot;) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wxGetSetting(&#39;writePhotosAlbum&#39;).then(res =&gt; &#123;      if(from == &quot;local&quot;)&#123;        wx.saveImageToPhotosAlbum(&#123;          filePath:src,          success: function (res) &#123;            resolve(res)          &#125;,fail(e)&#123;            reject(e)          &#125;        &#125;)      &#125;else if(from == &quot;web&quot;)&#123;        let fileName = new Date().valueOf();        wx.downloadFile(&#123;          url:src,          filePath:wx.env.USER_DATA_PATH + &#39;/&#39; + fileName + &#39;.jpg&#39;,          success(image)&#123;            wx.saveImageToPhotosAlbum(&#123;              filePath:image.filePath,              success: function (res) &#123;                resolve(res)              &#125;,fail(e)&#123;                reject(e)              &#125;            &#125;)          &#125;,fail(err)&#123;            reject(err)          &#125;        &#125;)      &#125;else&#123;        reject(&quot;wxSaveImageToPhotosAlbum:from is unknown&quot;)      &#125;    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;/** * 复制文字到剪切板 * @param &#123;*&#125; data  */const wxClipboardData = data =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.setClipboardData(&#123;      data: data,      success(res) &#123;        wx.getClipboardData(&#123;          success(res) &#123;            resolve(res)          &#125;,          fail(err) &#123;            reject(err)          &#125;        &#125;)      &#125;,      fail(err) &#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;/** * 打开文档 * @param &#123;*&#125; path  */const wxOpenDocument = path =&gt;&#123;  return new Promise((resolve, reject) =&gt; &#123;    wx.downloadFile(&#123;      url: path,      success: function (res) &#123;        const filePath = res.tempFilePath        wx.openDocument(&#123;          filePath: filePath,          success: function (res) &#123;            resolve(res)          &#125;,fail(err)&#123;            reject(err)          &#125;        &#125;)      &#125;,fail(err)&#123;        reject(err)      &#125;    &#125;)  &#125;)&#125;const wxMakePhoneCall = phone =&gt;&#123;  return new Promise((resolve, reject) =&gt; &#123;  let type = Object.prototype.toString.call(phone);  let phoneArray = []  if(type == &quot;[object String]&quot;)&#123;      phoneArray = [phone]  &#125;else if(type == &quot;[object Number]&quot;)&#123;    phoneArray = [phone.toString]  &#125;else if(type == &quot;[object Array]&quot;)&#123;    phoneArray = phone;  &#125;else&#123;    reject(&quot;wxMakePhoneCall:parameter type is error&quot;);    return;  &#125;  wx.showActionSheet(&#123;    itemList: phoneArray,    success: function (res) &#123;      wx.makePhoneCall(&#123;        phoneNumber: phone, //此号码并非真实电话号码，仅用于测试          success: function () &#123;          resolve()        &#125;,        fail: function (e) &#123;          reject(e)        &#125;      &#125;)      if (!res.cancel) &#123;        reject(res.tapIndex)      &#125;    &#125;  &#125;);&#125;)&#125;/** * 微信拉起支付 * @param &#123;*&#125; data  */const wxPayment = data =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    let &#123;      timeStamp,      nonceStr,      paySign    &#125; = data;    wx.requestPayment(&#123;      timeStamp,      nonceStr,      package:data.package,      signType: &#39;MD5&#39;,      paySign,      success(res) &#123;        resolve(res)      &#125;,      fail(res) &#123;        reject(res)      &#125;    &#125;)  &#125;)&#125;export &#123;  wxGetUserInfo,  wxLogin,  wxSaveImageToPhotosAlbum,  wxClipboardData,  wxOpenDocument,  wxMakePhoneCall,  wxPayment&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-使用mixin混入</title>
      <link href="2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8mixin%E6%B7%B7%E5%85%A5/"/>
      <url>2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8mixin%E6%B7%B7%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文用于实现微信小程序的mixin使用</p><span id="more"></span><h2 id="mixin理解"><a href="#mixin理解" class="headerlink" title="mixin理解"></a>mixin理解</h2><p>本意就是混入的意思,利用语言特性进行组合式操作.</p><p>如果你对<a href="https://cn.vuejs.org/v2/guide/mixins.html">vue中的mixin</a>有所了解,那么对mixin一定不会陌生,如果您使用过java语言,那么它解决<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030524000032">多重继承</a> 带来复杂继承链的问题，或者说是<code>多重继承</code>实现的一种技巧.</p><h2 id="微信小程序中的mixin理解"><a href="#微信小程序中的mixin理解" class="headerlink" title="微信小程序中的mixin理解"></a>微信小程序中的mixin理解</h2><p>了解过vue中的混入思路,我们可以将之转化到微信小程序中,可以劫持Page或者Component,改写函数并最终释放出来</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="javascript">// 保存原生的 Page 函数const originPage = Pageconst originComponent = ComponentPage = (options) =&gt; &#123;  const mixins = options.mixins  // mixins 必须为数组  if (Array.isArray(mixins)) &#123;    delete options.mixins    // mixins 注入并执行相应逻辑    options =  merge(mixins, options)  &#125;  // 释放原生 Page 函数  originPage(options)&#125;Component = (options) =&gt; &#123;  const mixins = options.mixins  // mixins 必须为数组  if (Array.isArray(mixins)) &#123;    delete options.mixins    // mixins 注入并执行相应逻辑    options = merge(mixins, options)  &#125;  // 释放原生 Component 函数  originComponent(options)&#125;// 定义小程序内置的属性/方法const originProperties = [&#39;data&#39;, &#39;properties&#39;, &#39;options&#39;, &#39;methods&#39;,&#39;observers&#39;]const originMethods = [&#39;onLoad&#39;, &#39;onReady&#39;, &#39;onShow&#39;, &#39;onHide&#39;, &#39;onUnload&#39;, &#39;onPullDownRefresh&#39;, &#39;onReachBottom&#39;, &#39;onShareAppMessage&#39;, &#39;onPageScroll&#39;, &#39;onTabItemTap&#39;]function merge(mixins, options) &#123;  mixins.forEach((mixin) =&gt; &#123;    if (Object.prototype.toString.call(mixin) !== &#39;[object Object]&#39;) &#123;      throw new Error(&#39;mixin 类型必须为对象！&#39;)    &#125;    // 遍历 mixin 里面的所有属性    for (let [key, value] of Object.entries(mixin)) &#123;      if (originProperties.includes(key)) &#123;        // 内置对象属性混入        options[key] = &#123;          ...value,          ...options[key]        &#125;      &#125; else if (originMethods.includes(key)) &#123;        // 内置方法属性混入，优先执行混入的部分        const originFunc = options[key]        options[key] = function (...args) &#123;          value.call(this, ...args)          return originFunc &amp;&amp; originFunc.call(this, ...args)        &#125;      &#125; else &#123;        // 自定义方法混入        options = &#123;          ...mixin,          ...options        &#125;      &#125;    &#125;  &#125;)  return options&#125;</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>可将其命名为mixin.js存入项目的utils或者core中作为工具;</p><p>在<code>app.js</code>顶部引入</p><pre><code class="javascript">//app.jsimport &#39;./utils/mixins.js&#39;</code></pre><p>可在项目根目录创建<code>common/mixins</code>文件夹,用于存放各种mixin文件</p><h4 id="Page的mixin定义风格如下"><a href="#Page的mixin定义风格如下" class="headerlink" title="Page的mixin定义风格如下:"></a>Page的mixin定义风格如下:</h4><pre><code class="javascript">//listMixin.jsmodule.exports = &#123;  data: &#123;    list: [],    page: 1, //页数    limit: 10, //每页最大数    lastPage: false, //是否为最后一页    isUpload: false, //是否在加载,  &#125;,   /**   * 监听滚动到底部   */  scrolltolower(e) &#123;    console.log(&quot;滚动到底部&quot;, e);    if (!this.data.lastPage &amp;&amp; !this.data.isUpload) &#123;      this.getList() //由被混入的文件实现getList()函数    &#125;;  &#125;&#125;</code></pre><p>使用方法如下:</p><pre><code class="javascript">Page(&#123;  mixins: [require(&#39;/common/mixins/ListMixin.js&#39;)]&#125;)</code></pre><h4 id="Component的mixin定义风格如下"><a href="#Component的mixin定义风格如下" class="headerlink" title="Component的mixin定义风格如下:"></a>Component的mixin定义风格如下:</h4><pre><code class="javascript">//componentListMixin.jsmodule.exports = &#123;  data: &#123;&#125;,  /**   * 组件的属性列表   */  properties: &#123;    //数据集合    list:&#123;      type:Array,      value:[]    &#125;,  &#125;,  methods:&#123;     /**     * 选择某项     */    chooseItem(event)&#123;      let item = event.currentTarget.dataset.cap;      this.triggerEvent(&#39;onChoose&#39;, item, &#123;&#125;)    &#125;  &#125; &#125;</code></pre><p>使用方法如下:</p><pre><code class="javascript">Component(&#123;  mixins: [require(&#39;/common/mixins/componentListMixin.js&#39;)]&#125;)</code></pre><p>功能实现参考了<a href="https://segmentfault.com/a/1190000019527762">此篇</a>文章,并对存在的问题进行修正</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-Object.entries is not a function解决办法</title>
      <link href="2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-Object.entries%20is%20not%20a%20function%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-Object.entries%20is%20not%20a%20function%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在部分机型上打开开发的小程序,vcosole显示<strong>Object.entries is not a function</strong>这类错误,可以使用以下方法手动添加<strong>Object.entries polyfill</strong>解决</p><span id="more"></span><pre><code>if (!Object.entries)  Object.entries = function( obj )&#123;    var ownProps = Object.keys( obj ),        i = ownProps.length,        resArray = new Array(i); // preallocate the Array    while (i--)      resArray[i] = [ownProps[i], obj[ownProps[i]]];        return resArray;  &#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
